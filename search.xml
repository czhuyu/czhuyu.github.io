<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-17]]></title>
    <url>%2F2019%2F06%2F15%2Fleetcode-17%2F</url>
    <content type="text"><![CDATA[给定一个仅包含数字 2-9 的字符串，返回所有它能表示的字母组合。 给出数字到字母的映射如下（与电话按键相同）。注意 1 不对应任何字母。 示例: 输入：”23”输出：[“ad”, “ae”, “af”, “bd”, “be”, “bf”, “cd”, “ce”, “cf”]. 来源：力扣（LeetCode）链接：https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657func letterCombinations(digits string) []string &#123; var res []string var tmpArr []int phoneMap := [10][4]string&#123; 2: &#123;"a", "b", "c", ""&#125;, 3: &#123;"d", "e", "f", ""&#125;, 4: &#123;"g", "h", "i", ""&#125;, 5: &#123;"j", "k", "l", ""&#125;, 6: &#123;"m", "n", "o", ""&#125;, 7: &#123;"p", "q", "r", "s"&#125;, 8: &#123;"t", "u", "v", ""&#125;, 9: &#123;"w", "x", "y", "z"&#125;, &#125; if digits == "" &#123; return res &#125; a := len(digits) digitsInt, _ := strconv.Atoi(digits) paramsArr := make([][4]string, 0) for &#123; if digitsInt &lt;= 0 &#123; break &#125; tmp := digitsInt % 10 tmpArr = append(tmpArr, tmp) digitsInt /= 10 &#125; for k := a-1; k &gt;= 0; k-- &#123; paramsArr = append(paramsArr, phoneMap[tmpArr[k]]) &#125; resAddress := &amp;res recu(paramsArr, 0, "", resAddress, a) return res&#125;func recu(numArr [][4]string, flag int, str string, strAddress *[]string, leng int) &#123; if flag == leng &#123; if len(str) == leng &#123; *strAddress = append(*strAddress, str) &#125; &#125; else &#123; for i := 0; i &lt; 4; i++ &#123; if flag == 0 &#123; str = "" if numArr[flag][i] == "" &#123; continue &#125; &#125; if i &gt; 0 &amp;&amp; len(str) &gt; 1 &#123; str = string([]byte(str)[0 : len(str)-1]) &#125; str += numArr[flag][i] recu(numArr, flag+1, str, strAddress, leng) &#125; &#125;&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些经验]]></title>
    <url>%2F2019%2F06%2F11%2F%E4%B8%80%E4%BA%9B%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[一些经验1.mysql的字段类型int(3)和int(4) 下面是官方文档的解释 11.2.5 Numeric Type Attributes MySQL supports an extension for optionally specifying the display width of integer data types inparentheses following the base keyword for the type. For example, INT(4) specifies an INT with adisplay width of four digits. This optional display width may be used by applications to display integervalues having a width less than the width specified for the column by left-padding them with spaces.(That is, this width is present in the metadata returned with result sets. Whether it is used is up to theapplication.)The display width does not constrain the range of values that can be stored in the column. Nor doesit prevent values wider than the column display width from being displayed correctly. For example, acolumn specified as SMALLINT(3) has the usual SMALLINT range of -32768 to 32767, and valuesoutside the range permitted by three digits are displayed in full using more than three digits.When used in conjunction with the optional (nonstandard) ZEROFILL attribute, the default padding ofspaces is replaced with zeros. For example, for a column declared as INT(4) ZEROFILL, a value of 5is retrieved as 0005. 这里的意思大概就是后面的数值代表的是一个显示宽度，当配合zerofill使用时，如果存储1到该字段中，int(3)会返回001而int(4)会返回0001 1234567891011121314151617mysql&gt; desc sss;+-------+--------------------------+------+-----+---------+----------------+| Field | Type | Null | Key | Default | Extra |+-------+--------------------------+------+-----+---------+----------------+| id | int(11) unsigned | NO | PRI | NULL | auto_increment || test3 | int(3) unsigned zerofill | NO | | NULL | || test4 | int(4) unsigned zerofill | NO | | NULL | |+-------+--------------------------+------+-----+---------+----------------+3 rows in set (0.01 sec)mysql&gt; select * from sss;+----+-------+-------+| id | test3 | test4 |+----+-------+-------+| 1 | 001 | 0001 |+----+-------+-------+1 row in set (0.00 sec) 需要注意的是，如果使用navicat这个可视化工具来测试这个的话test3和tes4都会返回1而没有填充的0，不知道是bug还是feature. 2.会输出什么？ 123&lt;?php echo $_COOKIE[&apos;username&apos;]; setcookie(&quot;username&quot;, 111, time()+5); 第一次请求的结果输出 1Notice: Undefined index: username in xxx.php on line 2 倒过来呢？ &lt;?php setcookie(&quot;username&quot;, 111, time()+5); echo $_COOKIE[&apos;username&apos;]; 12结果肯定是一样的，为什么？因为输出和setcookie在同一个php文件里面，这次会在响应头里面有set-cookie告诉浏览器存储这个cookie，而只有下次请求过来的时候php才会把请求头里面的cookie装到$_COOKIE变量里面，所以这两种情况输出的$_COOKIE都会是一个空数组，文档中也有这样一句描述：一旦设置 Cookie 后，下次打开页面时可以使用 $_COOKIE 读取。 Cookie 值同样也存在于 $_REQUEST。 文档中还有这样一句话 1setcookie() 定义了 Cookie，会和剩下的 HTTP 头一起发送给客户端。 和其他 HTTP 头一样，必须在脚本产生任意输出之前发送 Cookie（由于协议的限制）。 请在产生任何输出之前（包括 &lt;html&gt; 和 &lt;head&gt; 或者空格）调用本函数。 但是在测试过程中 123&lt;?php echo 111; setcookie(&quot;username&quot;, 111, time()+5); 上面这个代码的输出并没有什么异常，cookie的设置也成功了。查阅资料发现跟php.ini里面的缓冲区设置有关 php默认设置 1output_buffering = 4096 把ini中的output_buffering设置为0，就是不缓冲输出，返回如下 12111Warning: Cannot modify header information - headers already sent by (output started at index.php:2) in index.php on line 3 只有buffer写满时，才会发送到浏览器。也就是说缓冲区超过4k就会发送到浏览器，如果设置为0，那就没有缓冲区，出现了第一个echo的时候http包已经发送出去了。所以setcookie里面的信息是没有在response header里面的 还有其他办法吗？ ob_start()，这样超过设置的缓冲大小也不会立即发送到浏览器，这样就会当脚本运行完成，或者调用了ob_flush等清空缓冲区方法之后，才会输出到浏览器。 12345&lt;?php ob_start(); echo 111; setcookie(&quot;username&quot;, 111, time()+5); ob_flush();]]></content>
      <tags>
        <tag>经验</tag>
        <tag>tips</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php中的数组和hash表]]></title>
    <url>%2F2019%2F06%2F02%2Fphp%E4%B8%AD%E7%9A%84%E6%95%B0%E7%BB%84%E5%92%8Chash%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[php中的数组和hash表什么是hash表 根据设定的哈希函数H(key)和处理冲突的方法将一组关键字映像到一个有限的连续的地址集上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称作哈希表，这一映像过程称为哈希造表或散列，所得存储位置称哈希地址。 怎么理解呢？为什么需要这样一个结构呢？ 举个例子，我们有一个一维数组来存储34个省份的各种信息，假设存储时候他的key我们如果设置成省份的名称，那么我们就需要a[33]来存储所有的省份 省份 北京 上海 四川 … 广东 天气 晴 晴 晴 … 晴 总人口 xxx人 xxx人 xxx人 … xxx人 那么我们如果想找到四川的信息那我们就得从第一个a[0]的key开始比较直到找到a[x]的key == “四川”,然后取出a[x]里面所保存的内容。hash表怎么做呢？我们通过某个hash函数f(key)把四川转成某个数字来作为它在数组中存储的key，那当我们需要查找它时就直接f(四川)就知道它在数组中的位置，然后使用a[f(四川)]就能够取出来四川下所保存的信息，相当于我们没有经过任何的比较就查找到了四川的所有信息，当然这是理想情况，因为hash函数一定能把每个省份的名称映射成一个单独的key并且不重复不产生冲突吗？如果仅仅为了不重复造成了不能均匀地分布到地址集合中造成空间浪费呢？ 从定义中我们可以看到hash函数和处理冲突的方法就是hash表的核心 hash函数 构造hash函数的方法很多，什么是好的hash函数呢？应该说在能够把关键字集合均匀地映射到整个地址区间，有效减少冲突的函数就是好的hash函数。 构造hash函数的方法有很多：直接定址法/数字分析法/平方取中法/折叠法/除留余数法随机数法 在php中hash函数被称作DJBX33A (Daniel J. Bernstein, Times 33 with Addition) 具体实现如下 12345678910111213141516171819202122232425262728static inline ulong zend_inline_hash_func(const char *arKey, uint nKeyLength)&#123; register ulong hash = 5381; /* variant with the hash unrolled eight times */ for (; nKeyLength &gt;= 8; nKeyLength -= 8) &#123; hash = ((hash &lt;&lt; 5) + hash) + *arKey++; hash = ((hash &lt;&lt; 5) + hash) + *arKey++; hash = ((hash &lt;&lt; 5) + hash) + *arKey++; hash = ((hash &lt;&lt; 5) + hash) + *arKey++; hash = ((hash &lt;&lt; 5) + hash) + *arKey++; hash = ((hash &lt;&lt; 5) + hash) + *arKey++; hash = ((hash &lt;&lt; 5) + hash) + *arKey++; hash = ((hash &lt;&lt; 5) + hash) + *arKey++; &#125; switch (nKeyLength) &#123; case 7: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */ case 6: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */ case 5: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */ case 4: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */ case 3: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */ case 2: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; /* fallthrough... */ case 1: hash = ((hash &lt;&lt; 5) + hash) + *arKey++; break; case 0: break;EMPTY_SWITCH_DEFAULT_CASE() &#125; return hash;&#125; 核心如下 1234567891011unsigned int DJBHash(char *str)&#123; unsigned int hash = 5381; while (*str) &#123; hash += (hash &lt;&lt; 5) + (*str++); &#125; return (hash &amp; 0x7FFFFFFF);&#125; 一个字符串的key经过这个函数之后会返回一个无符号的整型，这个无符号整型就是php会真正存储使用到的key. 处理冲突 冲突可以减少，但是不能避免，所以还必须有处理冲突的方法 开放定址法/再hash法/链地址法 php中采用的是链地址法 如果冲突太多怎么办？或者恶意冲突呢？在鸟哥的blog里有一篇关于hash冲突的示例 http://www.laruence.com/2011/12/30/2435.html 123456789101112131415161718&lt;?php$size = pow(2, 16); $startTime = microtime(true);$array = array();for ($key = 0, $maxKey = ($size - 1) * $size; $key &lt;= $maxKey; $key += $size) &#123; $array[$key] = 0;&#125;$endTime = microtime(true);echo &apos;插入 &apos;, $size, &apos; 个恶意的元素需要 &apos;, $endTime - $startTime, &apos; 秒&apos;, &quot;\n&quot;; $startTime = microtime(true);$array = array();for ($key = 0, $maxKey = $size - 1; $key &lt;= $maxKey; ++$key) &#123; $array[$key] = 0;&#125;$endTime = microtime(true);echo &apos;插入 &apos;, $size, &apos; 个普通元素需要 &apos;, $endTime - $startTime, &apos; 秒&apos;, &quot;\n&quot;; 在我的机器上面运行得到了下面这个结果。 12插入 65536 个恶意的元素需要 29.219798088074 秒插入 65536 个普通元素需要 0.014147996902466 秒 可以看到差距确实是很明显的，具体原因就是每个需要插入的key都会产生hash冲突最后整个hash表变成了一个链表。由于这个链表会保持有序，所以每当下一个元素需要插入时，就要遍历去找它应该插入该到链表的那个位置造成了这个问题，而且需要遍历的节点个数是越来越多的。 php hash表结构图示 上图来自网络，侵删。 这张图比较清晰的展示了你如果在php中hash表的存储结构。 最左侧是hash表的结构体内容 1234567891011121314151617typedef struct _hashtable &#123; uint nTableSize; uint nTableMask; uint nNumOfElements; ulong nNextFreeElement; Bucket *pInternalPointer; /* Used for element traversal */ Bucket *pListHead; Bucket *pListTail; Bucket **arBuckets; dtor_func_t pDestructor; zend_bool persistent; unsigned char nApplyCount; zend_bool bApplyProtection;#if ZEND_DEBUG int inconsistent;#endif&#125; HashTable; 左二列就是上面描述的连续的地址区间，这里面所存储的都是Bucket类型的指针，保存的当然就是每个Bucket的地址。 Bucket就是保存数据的单元 1234567891011typedef struct bucket &#123; ulong h; /* Used for numeric indexing */ uint nKeyLength; void *pData; void *pDataPtr; struct bucket *pListNext; struct bucket *pListLast; struct bucket *pNext; struct bucket *pLast; const char *arKey;&#125; Bucket; 从图中或者从结构体定义中我们可以看到hash表结构体和Bucket结构体定义了很多指针或者是变量来存储Bucket相关的信息或者跟hash表相关的信息。 回到图中，在Bucket1插入之前，php先初始化了_hashtable这样一个结构体，初始化了一个连续的地址空间，里面保存的都是空指针，并且把Bucket **arBuckets;指向指针类型的指针指向了这个连续地址区间的第一个元素的地址。在实际的将这个元素保存到hash表的过程中，先根据hash函数确定了Bucket1应该存储到地址为1的这个位置，于是把地址为1的空指针指向了bucket1，然后插入Bucket2，由于hash函数Bucket2的key对应的地址也是1，一般来说在每个链hash key的值相同的链表中也是要保持关键词有序的，因为方便查找和添加，于是根据关键词的升序或者降序确定了Bucket2应当插入到Bucket1的前面。把Bucket2的pNext指向了Bucket1，把地址为1的指针执行了Bucket2，Bucket3和Bucket1插入的方式同理。 这里只是简要描述了插入的过程而没有说明每一个变量的改变和指针的改变，不然流程太长了。 Bucket里保存的信息的作用 123456789ulong h; /* Used for numeric indexing */ 这里php源码注释说会用到索引数字类型的时候uint nKeyLength; key的长度 void *pData; data相关void *pDataPtr; data相关struct bucket *pListNext; 在整个hashtable中按插入先后顺序的下一个bucket地址struct bucket *pListLast; 在整个hashtable中按插入先后顺序的上一个bucket地址struct bucket *pNext; 在key的hash结果相同的链表中下一个bucket的地址struct bucket *pLast; 在key的hash结果相同的链表中上一个bucket的地址const char *arKey; key 可以看到php的hashtable维护了很多的双向链表，一个是key相同的时候的双向链表，一个是整个hashtable顺序的双向链表，为什么要这么设计呢？ hashtable的链表应该是用于遍历的 而每个hash f(k)相等的时候的链表应该就是服务于元素的增删改查。 再看hashtable里面存储的信息 123456789101112uint nTableSize;uint nTableMask;uint nNumOfElements;ulong nNextFreeElement;Bucket *pInternalPointer; /* Used for element traversal */ 这里php源码注释说会用到元素遍历的时候Bucket *pListHead;Bucket *pListTail;Bucket **arBuckets;dtor_func_t pDestructor;zend_bool persistent;unsigned char nApplyCount;zend_bool bApplyProtection; 这里面保存的变量就跟php数组的操作函数有关系了 当我们使用foreach()来遍历输出一个数组时，他会按照元素的添加先后顺序来输出，怎么做到的呢？Bucket *pInternalPointer;这个指针的作用就体现出来了,首先他的值会跟pListHead一样指向第一个添加的Bucket的地址，然后输出就是 1print pInternalPointer-&gt;pData-&gt;pDataPtr 输出下一个元素呢 12pInternalPointer = pInternalPointer-&gt;pListNextprint pInternalPointer-&gt;pData-&gt;pDataPtr 一直到*pInternalPointer-&gt;pListNext为null的时候数组遍历就完成了，其他的一些函数 12345reset() pInternalPointer = pListHeadend() pInternalPointer = pListTailnext() pInternalPointer = pInternalPointer-&gt;pListNextprev() pInternalPointer = pInternalPointer-&gt;pListLastcurrent() pInternalPointer]]></content>
      <tags>
        <tag>php内核</tag>
        <tag>hash表</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[查找和排序算法]]></title>
    <url>%2F2019%2F05%2F31%2F%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[查找和排序算法查找算法1.顺序查找 2.二分查找 循环实现 123456789101112131415function midSearch($k,$arr)&#123; $left = 0; $right = count($arr); while($left &lt; $right)&#123; $mid = floor(($left + $right)/2); if($arr[$mid] == $k)&#123; return $mid; &#125;else if($arr[$mid] &gt; $k)&#123; $right = $mid - 1; &#125;else&#123; $left = $mid + 1; &#125; &#125; return -1;&#125; 递归实现 12345678910111213141516function binSearch($arr,$left,$right,$key)&#123; if($left &gt; $right)&#123; return -1; &#125;else&#123; $mid = floor(($left+$right)/2); if($key == $arr[$mid])&#123; return $mid; &#125;elseif ($key &lt; $arr[$mid]) &#123; $right = $mid - 1; return binSearch($arr,$left,$right,$key); &#125;else&#123; $left = $mid + 1; return binSearch($arr,$left,$right,$key); &#125; &#125;&#125; 排序算法一.内部排序 先定义一百个0-100整数元素组成的随机数数组和交换函数 123456789101112$n = 100;$a = [];for ($i=0; $i &lt; $n; $i++) &#123; $a[] = rand(0,$n);&#125;function swap(&amp;$arr,$i,$j)&#123; $temp = $arr[$i]; $arr[$i] = $arr[$j]; $arr[$j] = $temp;&#125; 1.冒泡排序 1234567891011function bubbleSort($arr)&#123; $n = count($arr); for($i = 0; $i &lt; $n-1; $i++)&#123; for($j = 0;$j &lt; $n-1-$i; $j++)&#123; if($arr[$j] &gt; $arr[$j+1])&#123; swap($arr,$j,$j+1); &#125; &#125; &#125; return $arr;&#125; 2.选择排序 简单选择排序 123456789101112131415function selectSort($arr)&#123; $n = count($arr); for($i = 0; $i &lt; $n-1; $i++)&#123; $minKey = $i; for($j = $i;$j &lt; $n; $j++)&#123; if($arr[$j] &lt; $arr[$minKey])&#123; $minKey = $j; &#125; &#125; if($i != $minKey)&#123; swap($arr,$i,$minKey); &#125; &#125; return $arr;&#125; 树形选择排序/堆排序 3.插入排序 直接插入排序 1234567891011121314function insertSort($arr)&#123; $n = count($arr); for($i = 1; $i &lt; $n; $i++)&#123; if($arr[$i] &lt; $arr[$i-1])&#123; $temp = $arr[$i]; $j = $i - 1; for($j;$j&gt;=0 &amp;&amp; $arr[$j] &gt; $temp;$j--)&#123; $arr[$j+1] = $arr[$j]; &#125; $arr[$j+1] = $temp; &#125; &#125; return $arr;&#125; 其他插入排序/希尔排序 4.快速排序 1234567891011121314151617181920212223242526function qsort(&amp;$arr, $left, $right)&#123; if($left &gt; $right)&#123; return; &#125; $i = $left; $k = $left; $j = $right; while($i &lt; $j)&#123; while($arr[$j] &gt;= $arr[$k] &amp;&amp; $i &lt; $j) $j--; swap($arr,$j,$k); $k = $j; while($arr[$i] &lt;= $arr[$k] &amp;&amp; $i &lt; $j) $i++; swap($arr,$i,$k); $k = $i; &#125; qsort($arr, $left, $k-1); qsort($arr, $k+1, $right);&#125;$n = count($a);qsort($a, 0, $n-1); 5.归并排序 6.基数排序 多关键字排序/链式基数排序 二.外部排序]]></content>
      <tags>
        <tag>算法</tag>
        <tag>查找</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php-cli]]></title>
    <url>%2F2019%2F05%2F27%2Fphp-cli%2F</url>
    <content type="text"><![CDATA[PHP-CLI在命令行输入 php -r “echo 111;” 就可以运行php代码并在控制台得到111的输出，那这中间经历了哪些步骤呢？ 从php的github项目中你可以下载到各个版本的源码，这里以5.6.40版本为例 php在命令行的处理源文件在{PHPSRC}/sapi/php_cli.c中 首先跟到main函数(在约1203行) 1378行 1234567891011 zend_first_try &#123;#ifndef PHP_CLI_WIN32_NO_CONSOLE if (sapi_module == &amp;cli_sapi_module) &#123;#endif exit_status = do_cli(argc, argv TSRMLS_CC);#ifndef PHP_CLI_WIN32_NO_CONSOLE &#125; else &#123; exit_status = do_cli_server(argc, argv TSRMLS_CC); &#125;#endif &#125; zend_end_try(); 这里的do_cli就是具体的实现了，跟到do_cli函数681行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475static int do_cli(int argc, char **argv TSRMLS_DC) /* &#123;&#123;&#123; */&#123; int c; ...... char *php_optarg = NULL, *orig_optarg = NULL; ...... zend_try &#123; CG(in_compilation) = 0; /* not initialized but needed for several options */ EG(uninitialized_zval_ptr) = NULL; while ((c = php_getopt(argc, argv, OPTIONS, &amp;php_optarg, &amp;php_optind, 0, 2)) != -1) &#123;zend_try &#123; CG(in_compilation) = 0; /* not initialized but needed for several options */ EG(uninitialized_zval_ptr) = NULL; while ((c = php_getopt(argc, argv, OPTIONS, &amp;php_optarg, &amp;php_optind, 0, 2)) != -1) &#123; switch (c) &#123; ...... case &apos;v&apos;: /* show php version &amp; quit */ php_printf(&quot;PHP %s (%s) (built: %s %s) %s\nCopyright (c) 1997-2016 The PHP Group\n%s&quot;, PHP_VERSION, cli_sapi_module.name, __DATE__, __TIME__,#if ZEND_DEBUG &amp;&amp; defined(HAVE_GCOV) &quot;(DEBUG GCOV)&quot;,#elif ZEND_DEBUG &quot;(DEBUG)&quot;,#elif defined(HAVE_GCOV) &quot;(GCOV)&quot;,#else &quot;&quot;,#endif get_zend_version() ); sapi_deactivate(TSRMLS_C); goto out; ...... default: break; &#125; &#125; /* Set some CLI defaults */ SG(options) |= SAPI_OPTION_NO_CHDIR; php_optind = orig_optind; php_optarg = orig_optarg; while ((c = php_getopt(argc, argv, OPTIONS, &amp;php_optarg, &amp;php_optind, 0, 2)) != -1) &#123; switch (c) &#123; ...... case &apos;r&apos;: /* run code from command line */ if (behavior == PHP_MODE_CLI_DIRECT) &#123; if (exec_direct || script_file) &#123; param_error = &quot;You can use -r only once.\n&quot;; break; &#125; &#125; else if (behavior != PHP_MODE_STANDARD || interactive) &#123; param_error = param_mode_conflict; break; &#125; behavior=PHP_MODE_CLI_DIRECT; exec_direct=php_optarg; break; ...... default: break; &#125; &#125; 这里就见到了我们经常使用的php -v，然后当然还有php -r。 1static int do_cli(int argc, char **argv TSRMLS_DC) /* &#123;&#123;&#123; */ 这里的argv就是从命令行获取到的内容,我们就跟着这个参数往下查找 1while ((c = php_getopt(argc, argv, OPTIONS, &amp;php_optarg, &amp;php_optind, 0, 2)) != -1) &#123; 686行有这样一部操作，然后我们看到当解析出命令行带了-r参数的时候，最主要做了两步操作 behavior=PHP_MODE_CLI_DIRECT; exec_direct=php_optarg; 所以这里传递引用&amp;php_optarg应该已经赋值了 再往下看会用在什么地方 123456case PHP_MODE_CLI_DIRECT: cli_register_file_handles(TSRMLS_C); if (zend_eval_string_ex(exec_direct, NULL, &quot;Command line code&quot;, 1 TSRMLS_CC) == FAILURE) &#123; exit_status=254; &#125; break; 然后把参数exec_direct传给zend_eval_string_ex，这个函数的实现在zend_excute_API.c文件中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798ZEND_API int zend_eval_stringl(char *str, int str_len, zval *retval_ptr, char *string_name TSRMLS_DC) /* &#123;&#123;&#123; */&#123; zval pv; zend_op_array *new_op_array; zend_op_array *original_active_op_array = EG(active_op_array); zend_uint original_compiler_options; int retval; if (retval_ptr) &#123; Z_STRLEN(pv) = str_len + sizeof(&quot;return ;&quot;) - 1; Z_STRVAL(pv) = emalloc(Z_STRLEN(pv) + 1); memcpy(Z_STRVAL(pv), &quot;return &quot;, sizeof(&quot;return &quot;) - 1); memcpy(Z_STRVAL(pv) + sizeof(&quot;return &quot;) - 1, str, str_len); Z_STRVAL(pv)[Z_STRLEN(pv) - 1] = &apos;;&apos;; Z_STRVAL(pv)[Z_STRLEN(pv)] = &apos;\0&apos;; &#125; else &#123; Z_STRLEN(pv) = str_len; Z_STRVAL(pv) = str; &#125; Z_TYPE(pv) = IS_STRING; /*printf(&quot;Evaluating &apos;%s&apos;\n&quot;, pv.value.str.val);*/ original_compiler_options = CG(compiler_options); CG(compiler_options) = ZEND_COMPILE_DEFAULT_FOR_EVAL; new_op_array = zend_compile_string(&amp;pv, string_name TSRMLS_CC); CG(compiler_options) = original_compiler_options; if (new_op_array) &#123; zval *local_retval_ptr=NULL; zval **original_return_value_ptr_ptr = EG(return_value_ptr_ptr); zend_op **original_opline_ptr = EG(opline_ptr); int orig_interactive = CG(interactive); EG(return_value_ptr_ptr) = &amp;local_retval_ptr; EG(active_op_array) = new_op_array; EG(no_extensions)=1; if (!EG(active_symbol_table)) &#123; zend_rebuild_symbol_table(TSRMLS_C); &#125; CG(interactive) = 0; zend_try &#123; zend_execute(new_op_array TSRMLS_CC); &#125; zend_catch &#123; destroy_op_array(new_op_array TSRMLS_CC); efree(new_op_array); zend_bailout(); &#125; zend_end_try(); CG(interactive) = orig_interactive; if (local_retval_ptr) &#123; if (retval_ptr) &#123; COPY_PZVAL_TO_ZVAL(*retval_ptr, local_retval_ptr); &#125; else &#123; zval_ptr_dtor(&amp;local_retval_ptr); &#125; &#125; else &#123; if (retval_ptr) &#123; INIT_ZVAL(*retval_ptr); &#125; &#125; EG(no_extensions)=0; EG(opline_ptr) = original_opline_ptr; EG(active_op_array) = original_active_op_array; destroy_op_array(new_op_array TSRMLS_CC); efree(new_op_array); EG(return_value_ptr_ptr) = original_return_value_ptr_ptr; retval = SUCCESS; &#125; else &#123; retval = FAILURE; &#125; if (retval_ptr) &#123; zval_dtor(&amp;pv); &#125; return retval;&#125;/* &#125;&#125;&#125; */ZEND_API int zend_eval_string(char *str, zval *retval_ptr, char *string_name TSRMLS_DC) /* &#123;&#123;&#123; */&#123; return zend_eval_stringl(str, strlen(str), retval_ptr, string_name TSRMLS_CC);&#125;/* &#125;&#125;&#125; */ZEND_API int zend_eval_stringl_ex(char *str, int str_len, zval *retval_ptr, char *string_name, int handle_exceptions TSRMLS_DC) /* &#123;&#123;&#123; */&#123; int result; result = zend_eval_stringl(str, str_len, retval_ptr, string_name TSRMLS_CC); if (handle_exceptions &amp;&amp; EG(exception)) &#123; zend_exception_error(EG(exception), E_ERROR TSRMLS_CC); result = FAILURE; &#125; return result;&#125;/* &#125;&#125;&#125; */ 可以看到最后执行的函数就是最上面的zend_eval_stringl Z_STRVAL(pv) = str; new_op_array = zend_compile_string(&amp;pv, string_name TSRMLS_CC); 经过词法分析/语法分析 这里得到的new_op_array应该就是包含了opcode的了 有一些比较眼熟的东西 12345zend_op_array 这里面会存放需要执行的opcodeEG 和代码的解释相关CG 和代码的执行相关zval_dtorzval_ptr_dtor EG 和 CG的定义可以在zend_globals_macros.h中可以找到 macro 宏指令的意思，这里就是C语言里面的特性了。 123456789101112131415161718/* Compiler */#ifdef ZTS# define CG(v) TSRMG(compiler_globals_id, zend_compiler_globals *, v)int zendparse(void *compiler_globals);#else# define CG(v) (compiler_globals.v)extern ZEND_API struct _zend_compiler_globals compiler_globals;int zendparse(void);#endif/* Executor */#ifdef ZTS# define EG(v) TSRMG(executor_globals_id, zend_executor_globals *, v)#else# define EG(v) (executor_globals.v)extern ZEND_API zend_executor_globals executor_globals;#endif zval_dtor和zval_ptr_dtor，我们使用一个unset操作想清除这个变量所占的内存时（可能只是引用计数减一），会从当前符号的哈希表中删除变量名对应的项， 在所有的操作执行完后，并对从符号表中删除的项调用一个析构函数，临时变量会调用zval_dtor，一般的变量会调用zval_ptr_dtor。 zval_ptr_dtor会做的事情就是：如果变量的引用计数为1，即减一后引用计数为0，直接清除变量。如果当前变量如果被缓存，则需要清除缓存；如果变量的引用计数大于1，即减一后引用计数大于0，则将变量放入垃圾列表。如果变量存在引用，则去掉其引用 1234567zend_try &#123; zend_execute(new_op_array TSRMLS_CC);&#125; zend_catch &#123; destroy_op_array(new_op_array TSRMLS_CC); efree(new_op_array); zend_bailout();&#125; zend_end_try(); 这里zend_execute(new_op_array TSRMLS_CC);肯定就是执行new_op_array里面的opcode了。 跟到{PHPSRC}/Zend/zend_vm_execute.h： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253ZEND_API void execute_ex(zend_execute_data *execute_data TSRMLS_DC)&#123; DCL_OPLINE zend_bool original_in_execution; original_in_execution = EG(in_execution); EG(in_execution) = 1; if (0) &#123;zend_vm_enter: execute_data = i_create_execute_data_from_op_array(EG(active_op_array), 1 TSRMLS_CC); &#125; LOAD_REGS(); LOAD_OPLINE(); while (1) &#123; int ret;#ifdef ZEND_WIN32 if (EG(timed_out)) &#123; zend_timeout(0); &#125;#endif if ((ret = OPLINE-&gt;handler(execute_data TSRMLS_CC)) &gt; 0) &#123; switch (ret) &#123; case 1: EG(in_execution) = original_in_execution; return; case 2: goto zend_vm_enter; break; case 3: execute_data = EG(current_execute_data); break; default: break; &#125; &#125; &#125; zend_error_noreturn(E_ERROR, &quot;Arrived at end of main loop which shouldn&apos;t happen&quot;);&#125;ZEND_API void zend_execute(zend_op_array *op_array TSRMLS_DC)&#123; if (EG(exception)) &#123; return; &#125; zend_execute_ex(i_create_execute_data_from_op_array(op_array, 0 TSRMLS_CC) TSRMLS_CC);&#125; 通过while(1)来执行从op_array里拿到的opcode进行执行。 opcode长什么样子呢？ 安装一个php扩展vld http://pecl.php.net/package/vld 安装扩展的方式 1234567891011121314151617181920phpize ./configure make &amp;&amp; make install把编译出来的动态链接库.so文件加到php.ini配置中vim /usr/local/php/etc/php.ini service php-fpm restartphp -ini | grep vldvldvld support =&gt; enabledvld.active =&gt; 0 =&gt; 0vld.col_sep =&gt; =&gt; vld.dump_paths =&gt; 1 =&gt; 1vld.execute =&gt; 1 =&gt; 1vld.format =&gt; 0 =&gt; 0vld.save_dir =&gt; /tmp =&gt; /tmpvld.save_paths =&gt; 0 =&gt; 0vld.skip_append =&gt; 0 =&gt; 0vld.skip_prepend =&gt; 0 =&gt; 0vld.verbosity =&gt; 1 =&gt; 1PWD =&gt; /usr/local/src/vld-0.14.0_SERVER[&quot;PWD&quot;] =&gt; /usr/local/src/vld-0.14.0 看到vld support =&gt; enabled就说明安装成功了 怎么使用呢？https://derickrethans.nl/projects.html#vld 在命令行运行 1php -r &quot;echo 1111;&quot; -dvld.active=1 我们得到了这样的结果 123456789101112131415161111root@czhuyu-Inspiron-5547:~# php -r &quot;echo 1111;&quot; -dvld.active=1Finding entry pointsBranch analysis from position: 0Jump found. (Code = 62) Position 1 = -2filename: Command line codefunction name: (null)number of ops: 2compiled vars: noneline #* E I O op fetch ext return operands------------------------------------------------------------------------------------- 1 0 E &gt; ECHO 1111 1 &gt; RETURN nullbranch: # 0; line: 1- 1; sop: 0; eop: 1; out1: -2path #1: 0, 1111 其中关键的部分应该就是这个op列下面的ECHO了 ECHO对应到源码中执行的操作就是ZEND_ECHO_SPEC_CONST_HANDLER 1234567891011121314151617static int ZEND_FASTCALL ZEND_ECHO_SPEC_CONST_HANDLER(ZEND_OPCODE_HANDLER_ARGS)&#123; USE_OPLINE zval *z; SAVE_OPLINE(); z = opline-&gt;op1.zv; if (IS_CONST == IS_TMP_VAR &amp;&amp; Z_TYPE_P(z) == IS_OBJECT) &#123; INIT_PZVAL(z); &#125; zend_print_variable(z); CHECK_EXCEPTION(); ZEND_VM_NEXT_OPCODE();&#125; 123456789ZEND_API int zend_print_variable(zval *var) &#123; return zend_print_zval(var, 0);&#125;ZEND_API int zend_print_zval(zval *expr, int indent) /* &#123;&#123;&#123; */&#123; return zend_print_zval_ex(zend_write, expr, indent);&#125; 123456789101112131415161718192021ZEND_API int zend_print_zval_ex(zend_write_func_t write_func, zval *expr, int indent) /* &#123;&#123;&#123; */&#123; zval expr_copy; int use_copy; zend_make_printable_zval(expr, &amp;expr_copy, &amp;use_copy); if (use_copy) &#123; expr = &amp;expr_copy; &#125; if (Z_STRLEN_P(expr) == 0) &#123; /* optimize away empty strings */ if (use_copy) &#123; zval_dtor(expr); &#125; return 0; &#125; write_func(Z_STRVAL_P(expr), Z_STRLEN_P(expr)); if (use_copy) &#123; zval_dtor(expr); &#125; return Z_STRLEN_P(expr);&#125; 这个write_func应该就是执行输出操作了 最后调用到的就是sapi_cli_single_write 1234567891011121314151617181920212223242526272829303132PHP_CLI_API size_t sapi_cli_single_write(const char *str, uint str_length TSRMLS_DC) /* &#123;&#123;&#123; */&#123;#ifdef PHP_WRITE_STDOUT long ret;#else size_t ret;#endif if (cli_shell_callbacks.cli_shell_write) &#123; size_t shell_wrote; shell_wrote = cli_shell_callbacks.cli_shell_write(str, str_length TSRMLS_CC); if (shell_wrote &gt; -1) &#123; return shell_wrote; &#125; &#125;#ifdef PHP_WRITE_STDOUT do &#123; ret = write(STDOUT_FILENO, str, str_length); &#125; while (ret &lt;= 0 &amp;&amp; errno == EAGAIN &amp;&amp; sapi_cli_select(STDOUT_FILENO TSRMLS_CC)); if (ret &lt;= 0) &#123; return 0; &#125; return ret;#else ret = fwrite(str, 1, MIN(str_length, 16384), stdout); return ret;#endif&#125;/* &#125;&#125;&#125; */ 我们都知道输出到控制台属于标准输出那肯定就是调用了write这个函数了 c语言的write函数是可以直接把内容输出到控制台的，至此，一个大概的流程就走完了，当然中间还有很多没有讲得很清楚的地方或许还有有错的地方，需要再看下文档，再梳理完善。 参考资料 https://github.com/php/php-src/tree/PHP-5.6.40 http://www.php-internals.com/]]></content>
      <tags>
        <tag>php</tag>
        <tag>php-cli</tag>
        <tag>php原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php内存管理与资源管理]]></title>
    <url>%2F2019%2F05%2F26%2Fphp%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E4%B8%8E%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[php内存管理与资源管理一.内存管理1.php5.3垃圾回收机制引用计数 https://www.php.net/manual/zh/features.gc.php在c中,​ 函数的参数和局部变量保存在栈上 由编译器自动分配释放​ malloc函数分来内存在堆上 需要手动使用free来释放 在php中, 每个php变量存在一个叫”zval”的变量容器中。每当一个变量被赋常量值的时候，就会生成下面zval这样的变量容器，一个_zval_struct结构体。而最终垃圾回收销毁的也是这样的变量容器。 12345678910111213141516171819typedef union _zvalue_value &#123; long lval; /* long value */ double dval; /* double value */ struct &#123; char *val; int len; &#125; str; HashTable *ht; /* hash table value */ zend_object_value obj; zend_ast *ast;&#125; zvalue_value;struct _zval_struct &#123; /* Variable information */ zvalue_value value; /* value */ zend_uint refcount__gc; zend_uchar type; /* active type */ zend_uchar is_ref__gc;&#125;; 简单类型的引用计数原理refcount__gc这个就是用以表示指向这个zval变量容器的变量(也称符号即symbol)个数 12&lt;?php$a = &quot;new string&quot;; 因为$a使用了这个变量的容器，所以zval的refcount的值用xdebug_debug_zval打印出来会是 1a: (refcount=1, is_ref=0)=&apos;new string&apos; 把一个变量赋值给另一变量将增加引用次数(refcount).，也就当$a被赋值给其他变量的时候这个refcount会增加。 1234567&lt;?php$a = &quot;new string&quot;;$c = $b = $a;xdebug_debug_zval( &apos;a&apos; );unset( $b, $c );xdebug_debug_zval( &apos;a&apos; );?&gt; 当然第一个打印出来的a的refcount会是3，当任何关联到某个变量容器的变量离开它的作用域(比如：函数执行结束)，或者对变量调用了函数 unset()时，”refcount“就会减1，所以第二个打印出来的a的refcount会是1。变量容器在”refcount“变成0时就被销毁 垃圾回收是为了解决内存泄露的问题,内存泄露指的是在程序申请了内存使用后而没有释放,最终导致内存消耗殆尽还有个名词叫做内存溢出 指的是只申请了int大的内存空间,却往里面存储long类型的数据。 这样就能保证不会产生内存泄漏了吗？ 123456&lt;?php $a = [&apos;one&apos;]; $a[] = &amp;$a; xdebug_debug_zval(&apos;a&apos;); unset($a); xdebug_debug_zval(&apos;a&apos;); 第一个xdebug的结果是 123456a:(refcount=2, is_ref=1),array (size=2) 0 =&gt; (refcount=1, is_ref=0),string &apos;one&apos; (length=3) 1 =&gt; (refcount=2, is_ref=1), &amp;array&lt; 第二个xdebug打印出来的结果会是 1a: no such symbol $a已经不在符号表了，但是数组的refcount变为的是1，还是会导致内存泄漏。这种怎么处理呢？这里就要讲下一个概念了： 回收周期 这是php手册中关于回收周期的图 我们使用一个unset操作想清除这个变量所占的内存时（可能只是引用计数减一），会从当前符号的哈希表中删除变量名对应的项， 在所有的操作执行完后，并对从符号表中删除的项调用一个析构函数，临时变量会调用zval_dtor，一般的变量会调用zval_ptr_dtor。 zval_ptr_dtor会做的事情就是：如果变量的引用计数为1，即减一后引用计数为0，直接清除变量。如果当前变量如果被缓存，则需要清除缓存；如果变量的引用计数大于1，即减一后引用计数大于0，则将变量放入垃圾列表。如果变量存在引用，则去掉其引用。 垃圾列表满时（10000个gc_root_buffer内存空间），调用gc_collect_cycles函数 步骤 B ，算法使用深度优先搜索查找所有可能的根，找到后将每个变量容器中的引用计数减1， 为确保不会对同一个变量容器减两次“1”，用灰色标记已减过1的。 步骤 C ，算法再一次对每个根节点使用深度优先搜索，检查每个变量容器的引用计数。 如果引用计数是 0 ，变量容器用白色来标记。如果引用次数大于0，则恢复在这个点上使用深度优先搜索而将引用计数减1的操作（即引用计数加1）， 然后将它们重新用黑色标记。 最后一步 D ，算法遍历根缓冲区以从那里删除变量容器根(zval roots)， 同时，检查是否有在上一步中被白色标记的变量容器。每个被白色标记的变量容器都被清除。 2.写时复制写时复制并不是PHP独有的 3.慎用&amp;二.资源管理数据库资源为例：​ 在java里面，会在try cache的finally结构中调用一个connection.close()去显式地关闭数据库的连接​ 在c++里面可以用__destruct析构函数在对象被销毁的时候来做close的操作​ 在php中呢？日常开发使用laravel框架的时候好像没注意到这个地方，也没有去显式地调用close方法.但肯定是有close的方法来提前释放掉这个连接的，laravel的数据库操作的实现是基于PDO来做的。​ 通过查阅文档https://www.php.net/manual/zh/pdo.connections.php，连接数据成功后，返回一个 PDO 类的实例给脚本，此连接在 PDO 对象的生存周期中保持活动。要想关闭连接，需要销毁对象以确保所有剩余到它的引用都被删除，可以赋一个 NULL 值给对象变量。如果不明确地这么做，PHP 在脚本结束时会自动关闭连接 ​ 那就是说php在脚本结束的时候会去自动清理数据库资源/文件等资源。在工作中我们会用到在后台长期运行的脚本，这种时候我们就需要自己去手动释放资源/内存等。 ​ 更详细的在 http://www.laruence.com/2012/07/25/2662.html 三.其他1.符号表参考资料： 1.php官方手册 2.http://www.php-internals.com/book/?p=chapt06/06-04-00-garbage-collection]]></content>
      <tags>
        <tag>php</tag>
        <tag>gc</tag>
        <tag>垃圾回收</tag>
        <tag>内存管理</tag>
        <tag>资源管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-15]]></title>
    <url>%2F2019%2F05%2F24%2Fleetcode-15%2F</url>
    <content type="text"><![CDATA[leetcode-15给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解答 12345678910111213141516171819202122232425262728293031323334353637383940414243func threeSum(nums []int) [][]int &#123; sort.Ints(nums) lenN := len(nums) var res [][]int for i := 0; i &lt; lenN; i++ &#123; l := i + 1 r := lenN - 1 if i &gt; 0 &amp;&amp; nums[i] == nums[i-1] &#123; continue &#125; for &#123; if l &gt;= r &#123; break &#125; sum := nums[i] + nums[l] + nums[r] if sum == 0 &#123; tmp := []int&#123;nums[i], nums[l], nums[r]&#125; res = append(res, tmp) l += 1 r -= 1 for &#123; if nums[l] == nums[l-1] &amp;&amp; l &lt; r &#123; l += 1 &#125; else &#123; break &#125; &#125; for &#123; if nums[r] == nums[r+1] &amp;&amp; l &lt; r &#123; r -= 1 &#125; else &#123; break &#125; &#125; &#125; else if sum &lt; 0 &#123; l += 1 &#125; else &#123; r -= 1 &#125; &#125; &#125; return res&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu]]></title>
    <url>%2F2019%2F05%2F24%2Fubuntu%2F</url>
    <content type="text"><![CDATA[淘汰笔记本的利用之前用的笔记本是dell5547，由于性能等各方面原因闲置下来了，当时还给它换了块固态硬盘，买的时候还是比较贵的，感觉扔了又比较可惜，于是打算安装个linux发行版在上面做服务器。 第一个问题是安装什么发行版本，centos还是ubuntu ​ 之前用过最多的还是centos这类的发行版，因为考虑到可以体验下gnome的桌面环境可以使用浏览器/phpstorm啥的再加上……(其实是因为安装centos遇到了显卡驱动的问题反正网上是这么说的，在安装系统时卡住了，搜了很多没有解决)。 ​ 对我而言redhat和debain系目前使用上最大的区别就是一个用yum来安装一个用apt-get。 下载Ubuntu 18.04.2 LTS (long time support?) 下载ultraiso 把系统写进u盘（第一步打开镜像iso文件 第二步写入硬盘），什么？要收费？试用30天！ 然后在笔记本开机的时候疯狂摁fn+f12（进入快捷选择启动盘），fn+f2进入boot引导设置界面.dell应该都是这样的，其他机型baidu/google.然后选择u盘，然后图形界面安装完成 ssh 12apt-get install openssh-serverservice ssh start 因为是用来作服务器，所以想让它启动就进入命令行模式 1234vim /etc/default/grub把这行 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;改成 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash 3&quot;update-grub 重启进入命令行模式 然后把笔记本盖子关上（减小功耗），ssh断了??? 1234vim /etc/systemd/logind.conf HandleLidSwitch 这个变量是用来控制合上盖子的系统操作的 我们把它的值改成 &quot;lock&quot;(锁屏)systemctl restart systemd-logind 然后就可以让它安静地做一个服务器了，你可以在上面安装lnmp…… 最后一个问题，查看电量 1find /sys/ -name capacity -exec cat &#123;&#125; \;]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql查询优化]]></title>
    <url>%2F2019%2F05%2F21%2Fmysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[mysql 查询优化一.使用explain分析sql索引使用情况有如下表结构 123456CREATE TABLE `index_test` ( `id` int(11) NOT NULL, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1explain SELECT * FROM `index_test` WHERE id = 1; id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE index_test const PRIMARY PRIMARY 4 const 1 id 唯一查询标识符 select_type SIMPLE/PRIMARY/UNION/SUBQUERY table 表名 type 类型 ​ The type column of EXPLAIN output describes how tables are joined. In JSON-formatted output,these are found as values of the access_type property. The following list describes the join types ​ 效率从高到低 1system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ​ const 主键或者唯一索引的等值查询 ​ index 会扫描所有的索引 ​ ref 通过特殊查找(即不会扫描所有索引) ​ all 扫描全表 ​ EXPLAIN SELECT * FROM index_test where name like ‘%a%’; ​ range 范围查询 ​ EXPLAIN SELECT * FROM index_test where id &gt; 1; ​ EXPLAIN SELECT * FROM index_test where name like ‘a%’; possible_keys 能够用到的索引，但可能在具体查询时并没有用到 ​ eg:给上表再增加一个普通索引 ADD INDEX idx_name (name) ; 12EXPLAIN SELECT * FROM `index_test` where id = 1 and `name` = &apos;aaa&apos;;这里将会看到possible_keys为PRIMARY,idx_name，但实际上key为PRIMARY key 当前查询使用到的索引 key_len 索引使用的字节数 ​ 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到. ref ​ The ref column shows which columns or constants are compared to the index named in the keycolumn to select rows from the table. rows 需要扫描的行数 ​ 在实际查询过程中，此值一般越小越好 Extra 额外 ​ 当所查询的字段在索引树上可以直接找到 会展示Using index 二.其他语句查询索引使用情况12show status like &apos;%Handler_read%&apos;;select * from schema_unused_indexes; 三.索引的最左匹配原则1.是什么 最左匹配是在复合索引中出现的概念 1ADD INDEX `idx_col1_col2_col3` (`col1`, `col2`, `col3`) ; 需要先使用最左边的索引才能继续使用第二个索引，以此类推 12345SELECT * FROM tbl_name WHERE col1=val1;SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;SELECT * FROM tbl_name WHERE col2=val2;SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3; 上面四句sql,1,2句会用到索引，而3,4句不会用到。 至于条件先后，mysql会做查询优化 1234eg:explain SELECT * FROM `index_test` where age = 20 and `name` = &apos;ccc&apos;;explain SELECT * FROM `index_test` where `name` = &apos;ccc&apos; and age = 20;这两句sql的explain结果是一致的 2.为什么 mysql的B-tree索引树的数据结构决定了构建三个字段索引的时候只能保持第一个字段有序的时候才能保证第二个有序，然后才能保证第三个有序。 那是什么样的数据结构呢？ 结构猜想： 树的整棵索引树的根节点上是col1组成的B-tree树,当根节点的值相等的时候（也就是col1相等的时候）又会在此节点上再新建根节点是col2组成的B-tree树，以此类推，所以当有联合索引的查找开始的时候，先依据col1找到相对应的类似于子树的地方再根据col2,col3去查找，为什么这样就会快呢？因为在这样的树上查找到该节点的时候会用到的就是二分查找（折半查找 O(log2n)）。 有点类似于orderBy col1 orderBy col2 orderBy col3。 3.引申 复合索引：建立在多列上的索引 单列索引：建立在某一列上的索引 复合索引的 优点： 1.建立一个索引可以用于多处 （col1,col2）和 col1这种条件都能用到 缺点： 1.使用有局限性，最左匹配 2.插入数据后索引树建立相对单列索引肯定是更复杂的，整体而言占用的空间肯定也更大。 四.其他1.数据库三范式 1NF：每个列原子性/不可再分 2NF：非主键字段完全依赖于主键而不是依赖于主键的一部分 3NF : 非主键字段需要直接依赖于主键而不是间接依赖 2.临时表 3.filesort]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel中的设计模式]]></title>
    <url>%2F2019%2F05%2F18%2FLaravel%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Laravel中的设计模式一、外观/门面模式12为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层次的接口，使得子系统更加容易使用外部与子系统的通信是通过一个门面(Facade)对象进行 ​ 在laravel中，我们可以通过Log::info / Cache::add/Route::get这样的静态方法来记录日志或者新增缓存或者路由定义,这一类方法的调用都可以使用一致的静态方法调用方式来调用. 以Log::info为例的运行流程 config/app.php 123&apos;aliases&apos; =&gt; [ Log&apos; =&gt; Illuminate\Support\Facades\Log::class,] vendor/laravel/framework/src/Illuminate/Support/Facades/Log.php 12345678910111213141516171819&lt;?phpnamespace Illuminate\Support\Facades;/** * @see \Illuminate\Log\Writer */class Log extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return &apos;log&apos;; &#125;&#125; 从上面可以看到Log里面没有info这个静态方法，然后查看extends的Facade__callStatic()魔术方法 当被调用的对象没有这个static方法时就会先执行此方法 1234567891011121314151617181920212223public static function __callStatic($method, $args) &#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException(&apos;A facade root has not been set.&apos;); &#125; switch (count($args)) &#123; case 0: return $instance-&gt;$method(); case 1: return $instance-&gt;$method($args[0]); case 2: return $instance-&gt;$method($args[0], $args[1]); case 3: return $instance-&gt;$method($args[0], $args[1], $args[2]); case 4: return $instance-&gt;$method($args[0], $args[1], $args[2], $args[3]); default: return call_user_func_array([$instance, $method], $args); &#125; &#125; 那Log最终new的实例是什么呢 vendor/laravel/framework/src/Illuminate/Log/LogServiceProvider.php 12345678910111213141516171819202122232425262728293031/** * Register the service provider. * * @return void */public function register()&#123; $this-&gt;app-&gt;singleton(&apos;log&apos;, function () &#123; return $this-&gt;createLogger(); &#125;);&#125; /** * Create the logger. * * @return \Illuminate\Log\Writer */public function createLogger()&#123; $log = new Writer( new Monolog($this-&gt;channel()), $this-&gt;app[&apos;events&apos;] ); if ($this-&gt;app-&gt;hasMonologConfigurator()) &#123; call_user_func($this-&gt;app-&gt;getMonologConfigurator(), $log-&gt;getMonolog()); &#125; else &#123; $this-&gt;configureHandler($log); &#125; return $log;&#125; 最终调用到的就是 vendor/laravel/framework/src/Illuminate/Log/Writer.php 1234567891011/** * Log an informational message to the logs. * * @param string $message * @param array $context * @return void */public function info($message, array $context = [])&#123; return $this-&gt;writeLog(__FUNCTION__, $message, $context);&#125;]]></content>
      <tags>
        <tag>laravel</tag>
        <tag>设计模式</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密相关]]></title>
    <url>%2F2019%2F05%2F18%2F%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[加密相关一.对称加密1.使用相同的密钥来进行加密解密 2.优缺点：计算小、加密快/不够安全 3.eg: AES 二.非对称加密1.公钥和私钥 公钥加密私钥解密/私钥加密公钥解密 2.优缺点：安全性高/加解密时间长、速度慢 3.eg:RSA 三.签名/摘要eg:MD5 四.httpshttps使用对称加密和非对称加密同时使用集合两者优点]]></content>
      <tags>
        <tag>加密解密</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk相关]]></title>
    <url>%2F2019%2F05%2F18%2Fawk%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[awk相关 统计nginx access_log中访问频率排前十的ip/URL etc awk ‘{print $1}’ access.log | sort | uniq -c | sort -nr -k1 | head -n 10 sort 让整个文件内容按行排序 相同内容的行会聚集到相邻的位置 uniq -c 去除重复列并且把重复次数产生新的一列展示到最前面 sort -nr -k1 把第一列的结果按照数字大小倒序排列 head -n 10 展示前十条 根据日志的格式调整print的列即可获取不同结果 列出当前目录下的所有文件 ls -lR |grep -v ^d|awk ‘{print $9}’ |tr -s ‘\n’]]></content>
      <tags>
        <tag>linux</tag>
        <tag>awk</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储引擎和索引结构]]></title>
    <url>%2F2019%2F04%2F25%2FMySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、数据结构 ​ MySQL的索引方法 B-tree 快速查找使用等于不等于条件或者范围（&gt;/&lt;/BETWEEN）条件的情形。 hash 只适用于MySQL的MEMORY存储引擎 二、MySQL （5.6为例）不同存储引擎的索引结构差别 ​ 这里讨论MySQL两种主要的存储引擎InnoDB 和 MyISAM InnoDB 每一个InnoDB都会有一个索引叫做聚集索引(clustered index)，通常这个索引也是主键（primary key），数据文件按主键聚集。每个索引的数据都会存在于此索引结构的树上。 每一个第二索引(Secondary Indexes)都会有一个字段来存储主键来关联上数据。 所有的InnoDB索引都是用B-trees,所有的索引记录都存在树的叶子结点。默认索引页大小为16KB。 MyISAM MySQL5.6版本之后默认存储引擎为InnoDB，如果需要MyISAM则需要在建表语句中指定。 同样支持B-tree索引、不支持聚集索引、不支持HASH索引。采用非聚集索引。 Primary Key和Secondary Key在结构上是一致的。MyISAM的索引文件不同之处在于Primary Key的key要求是唯一的，而Secondary Key的key可以重复。 和InnoDB的结构不同之处在于MyISAM的每个索引树的叶子节点存储的是数据的地址，索引文件数据文件分离。 三、BTREE树搜索算法 四、其他]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-内存置换策略]]></title>
    <url>%2F2019%2F04%2F25%2Fredis-%E5%86%85%E5%AD%98%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[redis1.数据类型 ​ k-v string list set zset 2.redis内存淘汰策略 超出内存限制报错 淘汰最近最少未使用 从设置了过期时间中的键中淘汰最近最少未使用 随机淘汰 从设置了过期时间中的键中随机淘汰 淘汰离过期时间最近的键 3.redis 持久化策略]]></content>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-host]]></title>
    <url>%2F2019%2F04%2F16%2Fnginx%26%26host%2F</url>
    <content type="text"><![CDATA[记录一次奇怪的响应在本地调预发布的一个接口 search.xxx.bz的时候，总是出现一次响应正常一次不正常的现象/搜索无果 上服务器查找nginx配置 到conf目录 1find -type f -name &apos;*.conf&apos;|xargs grep &apos;search.xxx.bz&apos; 发现一个反向代理配置 123456789server &#123; listen 80; server_name search.tff.bz; location / &#123; proxy_set_header Host $proxy_host; proxy_pass http://search.sss.com; &#125;&#125; 1find -type f -name &apos;*.conf&apos;|xargs grep &apos;search.sss.com&apos; 正常nginx server 配置 12345678server &#123; listen 80; server_name search.services.sss.com; root /xxxx/public; access_log logs/search.sss.com.access.log main; error_log logs/search.sss.com.error.log; include laravel;&#125; 无异样 之前尝试过在本地ping search.sss.com 结果为127.0.0.1无异样 在机器上curl调接口也没问题 仔细检查host 发现有两个配置 search.sss.com 188.8.8.8 search.sss.com 127.0.0.1 猜想nginx 在反向代理解析host 的时候两次分别取了不同的host配置，屏蔽第一个，问题解决。]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>host</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sphinx安装]]></title>
    <url>%2F2018%2F12%2F17%2FSphinx%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[坑1.安装Sphinx报错 1234567891011libsphinx.a(sphinx.o)：在函数‘xmlUnknownEncoding(void*, char const*, XML_Encoding*)’中：/mnt/Project/src/sphinx/src/sphinx.cpp:29116：对‘libiconv_open’未定义的引用libsphinx.a(sphinx.o)：在函数‘xmlUnknownEncoding(void*, char const*, XML_Encoding*)’中：sphinx.cpp:(.text+0x11ce)：对‘libiconv’未定义的引用sphinx.cpp:(.text+0x11ff)：对‘libiconv_close’未定义的引用collect2: 错误：ld 返回 1make[2]: *** [indexer] 错误 1make[2]: 离开目录“/mnt/Project/src/sphinx/src”make[1]: *** [all] 错误 2make[1]: 离开目录“/mnt/Project/src/sphinx/src”make: *** [all-recursive] 错误 1 以为是没有安装libiconv，yum安装还是报错 yum -y install libevent libevent-devel 百度 1.编译新增参数（注意这个改的是sphinx的解压包的src下的MakeFile）(推荐) ​ LIBS = -lm -lexpat -liconv -L/usr/local/lib 修改configure文件，找到“#define USE_LIBICONV 1”，将注释去掉，并将1改成0。 两个命令 12/usr/local/sphinx/bin/indexer --all //根据sphinx.conf的配置生成索引/usr/local/sphinx/bin/searchd //启动搜索引擎]]></content>
      <tags>
        <tag>sphinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sphinx 2.2.6-release 参考手册]]></title>
    <url>%2F2018%2F12%2F16%2FSphinx%2F</url>
    <content type="text"><![CDATA[Sphinx 2.2.11-release 参考手册免费的开源SQL全文搜索引擎 Copyright © 2001-2014 Andrew Aksyonoff Copyright © 2008-2014 Sphinx Technologies Inc, http://sphinxsearch.com 翻译校对 Czhuyu 第一章. 介绍1.1. 关于sphinx 是一个全文搜索引擎，公开发行于GPL 2.0，商业许可(例如 用于嵌入式)通过需要许可。 从技术上讲，Sphinx是一个独立的软件包提供快速的全文搜索功能的客户端软件。它特意被设计为跟SQL 数据库一体的去存储数据，并且可以简单地通过脚本语言连接。总之，Sphinx不依赖于任何特殊的数据库功能。 应用程序可以通过Sphinx的搜索守护进程searchd用以下三种连接方式：a)通过Sphinx自己实现的Mysql的网络协议(使用的一个小的SQL的子集叫做SphinxQL，这是推荐的方式)，b)通过自带的search API(SphinxAPI)或者c)通过Mysql服务的可插拔的存储引擎(SphinxSE)。 官方的原生SphinxAPI实现了PHP,Perl,Python,Ruby和Java在贡献的包里。API是非常轻量级的所以实现一个新的语言的API只需要几个小时就行。 从1.10的beta版本开始，Sphinx支持两种不同的后台索引：磁盘后台索引和实时后台索引。磁盘索引支持在线的全文索引重建，但是在线更新只支持非text的(属性)数据。实时索引支持在线的全文索引更新。上个版本只在磁盘索引中支持。 数据可以加载进磁盘索引用一个所以叫数据源。建立源可以直接从MySQL，PostgreSQL，MSSQL，ODBC compliant 数据库(Oracle等等)或者一个管道在TSV或者一个格式化的XML。新增一个数据源驱动被设计得经可能简单。实时索引，直到1.10beta版本为止，只能用SphinxQL。 就像名字一样，Sphinx是SQL Phrase Index译解缩写。是的，我知道关于CMU的Sphinx项目。 1.2. Sphinx特性Sphinx特性的关键是 索引和搜索的高性能 先进的索引和查询工具(灵活的并且富有特性的文本分词器,查询语言，几个不同的排名模式，等等); 先进的结果集后处理（SELECT表达式，WHERE,ORDER BY,GROUP BY,HAVING等在文本搜索中） 可扩展的久经考验地用于数十亿的文档，万亿字节的数据，每秒成千上万的请求。 方便的集合SQL和XML的数据源，和SphinxQL，SphinxAPI,和SphinxSE搜索接口； 简单的可伸缩分布式搜索。 扩大一点，Sphinx： 拥有很高的索引速度(达到 10-15MB/每秒每个核心在内部基准上)； 拥有很高的搜索速度（达到150-250/每秒每个核心对阵1,000,000文档，1.2G的数据在内部基准上） 拥有很高的扩展性(最大的已知的聚集索引超过了3,000,000,000文档，并且最繁忙的巅峰达到了500万次查询每天) 2.2. 编译安装Sphinx2.2.1 需要的工具在unix上，你需要下面的工具来建立和安装Sphinx 一个用来工作的c++的编译器，GNU gcc和clang是知名的用来工作。 一个好的make工具，GNU很出名用来工作 在windows上面，你会需要Microsoft Visual C/C++ Studio .Net 2005 或者以上。其他的编译器/环境也是一样的工作，但目前，你需要手动建立make文件(或者其他环境的特定项目文件) 2.2.2. 在Linux上编译安装2.6. Sphinx 废弃项目和更改默认的配置在2.2.1-beta版本我们决定开始去除一些老的功能，所有的非官方的弃用一段时间。现在我们正式通知你们关于它们。 修改如下： 32位的文档id已经被废弃了。我们的二进制发行版本现在默认都在64位的documentid的基础上建立。需要注意的是它们仍然可以用32位ID索引，但是这个支持最后会被移除。事实上，它前一阵子已经被废弃了，但是现在我们只想清除它。我们没有看到用这种方式来节省服务器RAM的任何意义。 dict=crc现在已经被废弃了。它是一大串约束。最重要的一个是关键词碰撞，并且没有通配符匹配支持。你可以获取更多的有关这些约束从我们的文档。2.7 第三章.索引3.1. 数据源需要被索引的数据可以来自非常不同的源：数据库，简单的文本数据，HTMl文件，邮箱等等。从Sphinx的视角看来，数据的索引是一个结构化文档的合集，每一个合集都会有相同的字段和属性。这一点和SQL相似的地方是每一个SQL的行对应一个文档，每一个列对应文档的字段或者属性。 由于Sphinx获得的不同的数据来源，需要不同的代码去取得数据然后准备索引。这些代码被称为数据源驱动（简单的说叫驱动或者叫数据源）. 在写这个文档的时候，现有的驱动有MySQL，PostgreSQL,MS SQL(on Windows),和ODBC.也有一类驱动叫做xmlpipe2，特殊的运行在命令行并且获取数据从它的标准输出中。看3.9 “xmlpipe2 数据源” 章节获取更多信息。在2.2.1的beta版本中tsvpipe和csvpipe数据源也搅入了进来。你可以获取更多信息从3.10”tsvpipe\csvpipe(Tab\Comma Separated Values)数据源” 索引有很多的数据来源。他们会有序地依照索引的定义规定通过非常相同的流程。所有的文档从这些源产生的灰合并起来就行他们来自单一的数据源。 3.2.全文本字段全文本字段（或者简单说是字段）是文本的内容被Sphinx索引，并且可以（快速地）被关键字搜索。 字段可以被命名，并且你可以限制你的搜索为一个字段（例如. 只通过”title”） 或者字段的子集（例如”title”和”abstract”）.Sphinx索引支持最大256个字段。但是，在2.0.1-beta版本索引被限制到了32个字段，因为并发在匹配引擎。完全的支持到256个字段在2.0.2-beta版本。 需要注意的是字段的源内容不会存储到sphinx中。你给Sphinx的文本，全文本索引（一个特殊的数据结构能够快速地被关键字搜索）建立来自于此文本。但是源文本会被丢弃掉。Sphinx假定你已经把这些内容保存到了其他的任何地方。 还有要说的是，不可能对源文本进行完全的结构重建，因为一些特殊的空格，大小写，标点符号会被丢失在索引的时候。理论上来说只有部分的被结构重建在文本里面，但是这将是一个十分缓慢的过程（尤其是如果CRC字典被使用，甚至不是保存关键字而是它们的hash） 3.3. 属性属性是每个文档关联的额外的值用来完成额外的过滤和排序在搜索过程中。 它经常被用于额外的全文索引结果基础不仅是匹配文档ID，rank，而且是其他的每个文档的值。举个例子，有可能需要用日期排序，然后是相关性，或者你需要用指定的价格区间搜索产品，或者筛选出某个作者的文章在你的博客里，或者按月分组。为了有效地做上面的这些事情，Sphinx允许附加一定数量的额外属性为每个文档，并且存储它们的值在全文本中，然后使用存储的值去过滤，排序，分组全文本匹配到的结果就变成了可能。 属性，不同于字段，不是全文索引。它们存储在索引中，但是他们不能当作全文本进行搜索，企图这样做会导致错误。 例如，不可能使用匹配表达式@column 1去匹配column为1的文档。如果column是一个熟悉，并且忽略搜索关联性工具。此外，属性返回的结果来自search daemon,而不是索引文本。 一个比较好的例子就是论坛讨论帖子的表。假定只需要标题和内容去搜索-但是有时候也需要搜索通过作者个子讨论（例如xxxxx）；或者给匹配到的结果按照post_date排序；或者用post_date按月份分组并计算每个组匹配的条数。 这个可以获得说明所有的提及的列（除了标题和内容，它们是全文本字段）作为属性，索引它们，然后用API调用设置过滤器，排序和分组。这里是一个例子。 Example sphinx.conf part: 1234567...sql_query = SELECT id, title, content, \ author_id, forum_id, post_date FROM my_forum_postssql_attr_uint = author_idsql_attr_uint = forum_idsql_attr_timestamp = post_date... Example application code (in PHP) 12345678// only search posts by author whose ID is 123$cl-&gt;SetFilter ( &quot;author_id&quot;, array ( 123 ) );// only search posts in sub-forums 1, 3 and 7$cl-&gt;SetFilter ( &quot;forum_id&quot;, array ( 1,3,7 ) );// sort found posts by posting date in descending order$cl-&gt;SetSortMode ( SPH_SORT_ATTR_DESC, &quot;post_date&quot; ); 第四章. 实时索引实时索引是一个新的后台让你新增，更新，或者删除文档在飞速中。实时索引在1.10-beta中加入。当你需要查询实时索引的时候你可以使用SphinxAPI,SphinxQL,或者SphinxSE，更新他们只可能通过SphinxQL在现在。完整的SphinxQL参考在第八张章节。 4.1. 实时索引概览实时索引应该声明在sphinx.conf，就像所有的其他索引类型一样。]]></content>
      <tags>
        <tag>sphinx</tag>
        <tag>搜索引擎</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cookie && Session]]></title>
    <url>%2F2018%2F03%2F16%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[Cookie &amp;&amp; Session一、cookie 定义: 是一种在浏览器端储存数据并以此来跟踪和识别用户的机制，是http头的一部分 使用方法:设置cookie函数原型: 1setcookie ( string $name [, string $value = &quot;&quot; [, int $expire = 0 [, string $path = &quot;&quot; [, string $domain = &quot;&quot; [, bool $secure = false [, bool $httponly = false ]]]]]] ) : bool setcookie() 定义了 Cookie，会和剩下的 HTTP 头一起发送给客户端。 和其他 HTTP 头一样，必须在脚本产生任意输出之前发送 Cookie（由于协议的限制）。 请在产生任何输出之前（包括 和 或者空格）调用本函数。 expire以秒为单位，设置一个小时的有效期即是time()+3600 一旦设置 Cookie 后，下次打开页面时可以使用 $_COOKIE 读取。 Cookie 值同样也存在于 $_REQUEST。 服务器端通过http头将cookie的信息传递到客户端里面包括了cookie的内容和生存时间 清除cookie 如果未设置cookie有效期，默认情况下cookie在浏览器关闭时会清除，如果设置了有效期且想提前结束采用如下方法。 1setcookie( ‘name ‘, ‘zhangsan ‘,time()-1);||unset($_COOKIE[ ‘name ‘]); 二、session 定义在并发访问时由一个方法来保存某些数据.从而使你能够构建更多的定制程序 从而提高你的 web 网站的吸引力一个访问者访问你的 web 网站将被分配一个唯一的 id, 就是所谓的会话 id. 这个 id 可以存储在用户端的一个cookie中，也可以通过 URL 进行传递 使用方法Example #1 page1.php 1234567891011121314151617&lt;?php// page1.phpsession_start();echo &apos;Welcome to page #1&apos;;$_SESSION[&apos;favcolor&apos;] = &apos;green&apos;;$_SESSION[&apos;animal&apos;] = &apos;cat&apos;;$_SESSION[&apos;time&apos;] = time();// 如果使用 cookie 方式传送会话 IDecho &apos;&lt;br /&gt;&lt;a href=&quot;page2.php&quot;&gt;page 2&lt;/a&gt;&apos;;// 如果不是使用 cookie 方式传送会话 ID，则使用 URL 改写的方式传送会话 IDecho &apos;&lt;br /&gt;&lt;a href=&quot;page2.php?&apos; . SID . &apos;&quot;&gt;page 2&lt;/a&gt;&apos;;?&gt; 请求 page1.php 页面之后， 第二个页面 page2.php 会包含会话数据。 请查阅 会话参考 获取更多关于 会话 ID 传送的信息， 在该参考页面中有关于常量 SID 的详细说明。 Example #2 page2.php 1234567891011121314&lt;?php// page2.phpsession_start();echo &apos;Welcome to page #2&lt;br /&gt;&apos;;echo $_SESSION[&apos;favcolor&apos;]; // greenecho $_SESSION[&apos;animal&apos;]; // catecho date(&apos;Y m d H:i:s&apos;, $_SESSION[&apos;time&apos;]);// 类似 page1.php 中的代码，你可能需要在这里处理使用 SID 的场景echo &apos;&lt;br /&gt;&lt;a href=&quot;page1.php&quot;&gt;page 1&lt;/a&gt;&apos;;?&gt;]]></content>
      <tags>
        <tag>http</tag>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day3]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day3%2F</url>
    <content type="text"><![CDATA[Binary Tree (Traverse A Tree)Binary Tree Preorder Traversal/*&nbsp;&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.&nbsp;&nbsp;type&nbsp;TreeNode&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Val&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;TreeNode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;TreeNode&nbsp;&nbsp;}&nbsp;/func&nbsp;preorderTraversal(root&nbsp;TreeNode)&nbsp;[]int&nbsp;{ var&nbsp;arr&nbsp;[]int if&nbsp;root&nbsp;==&nbsp;nil&nbsp;{ return&nbsp;arr } arr&nbsp;=&nbsp;append(arr,&nbsp;root.Val) arr1&nbsp;:=&nbsp;preorderTraversal(root.Left) arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr1) arr2&nbsp;:=&nbsp;preorderTraversal(root.Right) arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr2) return&nbsp;arr}func&nbsp;arrmerge(arr&nbsp;[]int,&nbsp;arr1&nbsp;[]int)&nbsp;[]int&nbsp;{​ for&nbsp;_,&nbsp;v&nbsp;:=&nbsp;range&nbsp;arr1&nbsp;{​ arr&nbsp;=&nbsp;append(arr,&nbsp;v)​ }​ return&nbsp;arr}Binary Tree Inorder Traversalfunc&nbsp;inorderTraversal(root&nbsp;TreeNode)&nbsp;[]int&nbsp;{​ var&nbsp;arr&nbsp;[]int​ if&nbsp;root&nbsp;==&nbsp;nil&nbsp;{​ return&nbsp;arr​ }​ arr1&nbsp;:=&nbsp;inorderTraversal(root.Left)​ arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr1)​ arr&nbsp;=&nbsp;append(arr,&nbsp;root.Val)​ arr2&nbsp;:=&nbsp;inorderTraversal(root.Right)​ arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr2)​ return&nbsp;arr}Binary Tree Postorder Traversalfunc&nbsp;postorderTraversal(root&nbsp;*TreeNode)&nbsp;[]int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;arr&nbsp;[]int​ if&nbsp;root&nbsp;==&nbsp;nil&nbsp;{​ return&nbsp;arr​ }​ arr1&nbsp;:=&nbsp;postorderTraversal(root.Left)​ arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr1)​ arr2&nbsp;:=&nbsp;postorderTraversal(root.Right)​ arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr2)&nbsp;&nbsp;&nbsp;&nbsp;arr&nbsp;=&nbsp;append(arr,&nbsp;root.Val)​ return&nbsp;arr}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-2]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day4%2F</url>
    <content type="text"><![CDATA[2.&nbsp;Add Two NumbersYou are given two&nbsp;non-empty&nbsp;linked lists representing two non-negative integers. The digits are stored in&nbsp;reverse order&nbsp;and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.ExampleInput:&nbsp;(2&nbsp;-&gt;&nbsp;4&nbsp;-&gt;&nbsp;3)&nbsp;+&nbsp;(5&nbsp;-&gt;&nbsp;6&nbsp;-&gt;&nbsp;4)Output:&nbsp;7&nbsp;-&gt;&nbsp;0&nbsp;-&gt;&nbsp;8Explanation:&nbsp;342&nbsp;+&nbsp;465&nbsp;=&nbsp;807./*&nbsp;&nbsp;Definition&nbsp;for&nbsp;singly-linked&nbsp;list.&nbsp;&nbsp;type&nbsp;ListNode&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Val&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Next&nbsp;ListNode&nbsp;&nbsp;}&nbsp;/func&nbsp;addTwoNumbers(l1&nbsp;ListNode,&nbsp;l2&nbsp;ListNode)&nbsp;ListNode&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;i1&nbsp;:=&nbsp;0 i2&nbsp;:=&nbsp;0 p&nbsp;:=&nbsp;l1 j&nbsp;:=&nbsp;0 for&nbsp;{ if&nbsp;p&nbsp;!=&nbsp;nil&nbsp;{ i1&nbsp;+=&nbsp;p.Val&nbsp;&nbsp;int(math.Pow(float64(10),&nbsp;float64(j))) j++ p&nbsp;=&nbsp;p.Next }&nbsp;else&nbsp;{ break } } j&nbsp;=&nbsp;0 p&nbsp;=&nbsp;l2 for&nbsp;{ if&nbsp;p&nbsp;!=&nbsp;nil&nbsp;{ i2&nbsp;+=&nbsp;p.Val&nbsp;&nbsp;int(math.Pow(float64(10),&nbsp;float64(j))) j++ p&nbsp;=&nbsp;p.Next }&nbsp;else&nbsp;{ break } } revres&nbsp;:=&nbsp;i1&nbsp;+&nbsp;i2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(revres) head&nbsp;:=&nbsp;new(ListNode) p&nbsp;=&nbsp;head for&nbsp;{ if&nbsp;revres&nbsp;==&nbsp;0&nbsp;{ break }&nbsp;else&nbsp;{ p.Val&nbsp;=&nbsp;revres&nbsp;%&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; revres&nbsp;=&nbsp;revres&nbsp;/&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;revres&nbsp;!=&nbsp;0{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;:=&nbsp;new(ListNode) &nbsp;&nbsp;&nbsp;&nbsp;p.Next&nbsp;=&nbsp;node &nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;p.Next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} } }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;l1 for&nbsp;{ if&nbsp;p.Next&nbsp;==&nbsp;nil&nbsp;{ break } fmt.Printf(&quot;%d\t&quot;,&nbsp;p.Val) p&nbsp;=&nbsp;p.Next }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;head&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp; 后面出现了位数很长的用例，所以换成采用数组来暂存单链表func&nbsp;addTwoNumbers(l1&nbsp;ListNode,&nbsp;l2&nbsp;ListNode)&nbsp;ListNode&nbsp;{ var&nbsp;i1&nbsp;[]int var&nbsp;i2&nbsp;[]int p&nbsp;:=&nbsp;l1 for&nbsp;{ if&nbsp;p&nbsp;!=&nbsp;nil&nbsp;{ i1&nbsp;=&nbsp;append(i1,&nbsp;p.Val) p&nbsp;=&nbsp;p.Next }&nbsp;else&nbsp;{ break } } p&nbsp;=&nbsp;l2 for&nbsp;{ if&nbsp;p&nbsp;!=&nbsp;nil&nbsp;{ i2&nbsp;=&nbsp;append(i2,&nbsp;p.Val) p&nbsp;=&nbsp;p.Next }&nbsp;else&nbsp;{ break } } head&nbsp;:=&nbsp;new(ListNode) p&nbsp;=&nbsp;head lenthi1&nbsp;:=&nbsp;len(i1) lenthi2&nbsp;:=&nbsp;len(i2) if&nbsp;lenthi1&nbsp;!=&nbsp;lenthi2&nbsp;{ if&nbsp;lenthi1&nbsp;&lt;&nbsp;lenthi2&nbsp;{ for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;lenthi2-lenthi1;&nbsp;i++&nbsp;{ i1&nbsp;=&nbsp;append(i1,&nbsp;0) } }&nbsp;else&nbsp;{ for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;lenthi1-lenthi2;&nbsp;i++&nbsp;{ i2&nbsp;=&nbsp;append(i2,&nbsp;0) } } } lenthi1&nbsp;=&nbsp;len(i1) lenthi2&nbsp;=&nbsp;len(i2) flag&nbsp;:=&nbsp;0 for&nbsp;i,&nbsp;_&nbsp;:=&nbsp;range&nbsp;i1&nbsp;{ sum&nbsp;:=&nbsp;i1[i]&nbsp;+&nbsp;i2[i] if&nbsp;i&nbsp;&lt;&nbsp;lenthi1-1&nbsp;{ if&nbsp;(sum)/10&nbsp;&gt;&nbsp;0&nbsp;{ i1[i+1]&nbsp;+=&nbsp;1 } }&nbsp;else&nbsp;{ if&nbsp;(sum)/10&nbsp;&gt;&nbsp;0&nbsp;{ flag&nbsp;=&nbsp;1 } } p.Val&nbsp;=&nbsp;sum&nbsp;%&nbsp;10 if&nbsp;i&nbsp;&lt;&nbsp;lenthi1-1&nbsp;{ node&nbsp;:=&nbsp;new(ListNode) p.Next&nbsp;=&nbsp;node p&nbsp;=&nbsp;p.Next } } if&nbsp;flag&nbsp;==&nbsp;1&nbsp;{ node&nbsp;:=&nbsp;new(ListNode) node.Val&nbsp;=&nbsp;1 p.Next&nbsp;=&nbsp;node } return&nbsp;head}]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP OPTIONS]]></title>
    <url>%2F2017%2F03%2F16%2FHTTP%20OPTIONS%2F</url>
    <content type="text"><![CDATA[幂等和非幂等 执行一次和执行很多次同样的操作是否是一样的 GET/PUT/DELETE 幂等 POST 非幂等]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php内置数组排序]]></title>
    <url>%2F2017%2F03%2F16%2FPHP%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day1%2F</url>
    <content type="text"><![CDATA[1.&nbsp;Two SumGiven an array of integers, return&nbsp;indices&nbsp;of the two numbers such that they add up to a specific target.You may assume that each input would have&nbsp;exactly&nbsp;one solution, and you may not use the&nbsp;same&nbsp;element twice.Example:Given&nbsp;nums&nbsp;=&nbsp;[2,&nbsp;7,&nbsp;11,&nbsp;15],&nbsp;target&nbsp;=&nbsp;9,Because&nbsp;nums[0]&nbsp;+&nbsp;nums[1]&nbsp;=&nbsp;2&nbsp;+&nbsp;7&nbsp;=&nbsp;9,return&nbsp;[0,&nbsp;1].func&nbsp;twoSum(nums&nbsp;[]int,&nbsp;target&nbsp;int)&nbsp;[]int&nbsp;{ var&nbsp;arr&nbsp;[]intEXIT: for&nbsp;i,&nbsp;&nbsp;:=&nbsp;range&nbsp;nums&nbsp;{ for&nbsp;j,&nbsp;&nbsp;:=&nbsp;range&nbsp;nums&nbsp;{ if&nbsp;(nums[i]+nums[j])&nbsp;==&nbsp;target&nbsp;&amp;&amp;&nbsp;i&nbsp;!=&nbsp;j&nbsp;{ arr&nbsp;=&nbsp;append(arr,&nbsp;i) arr&nbsp;=&nbsp;append(arr,&nbsp;j) break&nbsp;EXIT } } } return&nbsp;arr}]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F03%2F16%2FGithub%2F</url>
    <content type="text"><![CDATA[首先有两种使用方式 1.先在git官网上建立一个git仓库，然后git clone到本地&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.直接在本地cd进一个文件夹 git init配置用户名和email&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;git config –global user.name &#39;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;git config –global user.email xxx@xxx.com简单使用命令 &nbsp;git add .&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git status&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git commit -m &quot;The First Upload&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;git push -u origin master&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.3]]></title>
    <url>%2F2017%2F03%2F16%2F2017.3%2F</url>
    <content type="text"><![CDATA[git http://www.runoob.com/w3cnote/git-guide.htmljs编辑器 http://www.cnblogs.com/lhb25/p/html5-wysisyg-inline-editor.htmlJavaEE 注解和XMLhttp://blog.csdn.net/qmw19910301/article/details/52712893]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装nginx]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[到nginx.org下载wget http://nginx.org/download/nginx-1.10.0.tar.gz解压压缩包环境配置Cd到解压出来的nginx目录中有configure目录的地方进行环境配置./configure –prefix=/usr/local/nginxⅠ.如果遇到提示缺少pcre库到www.pcre.org下载pcre库，if解压到/usr/local/src/pcre-sourceⅡ.1.6版本以后的版本制定pcre源码目录./configure –prefix=/usr/local/nginx–with-pcre=/usr/local/src/pcre-source之前的版本制定安装目录./configure –prefix=/usr/local/nginx–with-pcre=/usr/pcre4.编译安装 make &amp;&amp; make install5.启动nginx ./sbin/nginx重启./sbin/nginx –s reloadException:如果遇到80端口被httpd(Apache)占了Pkill -9 httpd如果无法访问检查防火墙设置]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写时复制和引用计数]]></title>
    <url>%2F2017%2F03%2F16%2F%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/phpcoder/p/4462210.html]]></content>
      <tags>
        <tag>php</tag>
        <tag>写时复制</tag>
        <tag>引用计数</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次完整的请求过程]]></title>
    <url>%2F2017%2F03%2F16%2F%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浏览器一次完整的请求过程]]></content>
      <tags>
        <tag>http</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装mysql]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Mysql%2F</url>
    <content type="text"><![CDATA[1、mysql 官网下载适合的压缩包，格式为mysql-x.x.xx-linuxxxx.tar.gz2、解压后配置配置帮助 ./configure –help3、groupadd mysqluseradd –g mysql mysqlcd到mysql的解压目录chown –R mysql .chgrp –R mysql .4、./scripts/mysql_install_db –user=mysql如果提示laibaio.1的相关错误yum install libaioso.1 libaio5、把目录权限还给rootchown –R root .chown –R mysql datamkdir /var/run/mysqldchown mysql /var/run/mysqldchgrp mysql /var/run/mysqld6、启动mysql./bin/mysqld_safe –user=mysql &amp;7、连接mysql ./bin/mysql –uroot -p如果报错 建立软连接或者直接将sock文件复制过去建立软连接方法ln /var/lib/mysql/mysql.sock /tmp/mysql.sock8、修改密码update user set Password=password(你想要的密码) where Host=’localhost’ and User= ‘root ‘;delete from user where Password= ‘’;flush privileges;]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-4]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day5%2F</url>
    <content type="text"><![CDATA[3.&nbsp;Longest Substring Without Repeating CharactersGiven a string, find the length of the&nbsp;longest substring&nbsp;without repeating characters.Examples:Given&nbsp;&quot;abcabcbb&quot;, the answer is&nbsp;&quot;abc&quot;, which the length is 3.Given&nbsp;&quot;bbbbb&quot;, the answer is&nbsp;&quot;b&quot;, with the length of 1.Given&nbsp;&quot;pwwkew&quot;, the answer is&nbsp;&quot;wke&quot;, with the length of 3. Note that the answer must be a&nbsp;substring,&nbsp;&quot;pwke&quot;&nbsp;is a&nbsp;subsequence&nbsp;and not a substring.func&nbsp;lengthOfLongestSubstring(s&nbsp;string)&nbsp;int&nbsp;{ arr&nbsp;:=&nbsp;make(map[rune]int) start&nbsp;:=&nbsp;0 maxlen&nbsp;:=&nbsp;0 for&nbsp;i,&nbsp;v&nbsp;:=&nbsp;range&nbsp;[]rune(s)&nbsp;{ if&nbsp;pre,&nbsp;ok&nbsp;:=&nbsp;arr[v];&nbsp;ok&nbsp;&amp;&amp;&nbsp;pre&nbsp;&gt;=&nbsp;start&nbsp;{ start&nbsp;=&nbsp;pre&nbsp;+&nbsp;1 } if&nbsp;i-start+1&nbsp;&gt;&nbsp;maxlen&nbsp;{ maxlen&nbsp;=&nbsp;i&nbsp;-&nbsp;start&nbsp;+&nbsp;1 } arr[v]&nbsp;=&nbsp;i } return&nbsp;maxlen}]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装laravel]]></title>
    <url>%2F2017%2F03%2F16%2F%E5%AE%89%E8%A3%85Laravel%2F</url>
    <content type="text"><![CDATA[一、根据官方文档需要安装几个php的扩展 Openssl/PDO/Mbstring/Tokenizer/XML二、Linux下可以使用Composer来安装Laravel&nbsp; 1.全局安装Composer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curl -sS https://getcomposer.org/installer | php&nbsp;&nbsp;&nbsp;&nbsp;mv composer.phar /usr/local/bin/composer&nbsp; &nbsp; &nbsp;解决更新慢的问题&nbsp;&nbsp;&nbsp;&nbsp;composer config repo.packagist composer https://packagist.phpcomposer.com&nbsp;&nbsp;&nbsp;&nbsp;composer –version查看是否安装成功&nbsp; 2.利用Composer安装Laravel&nbsp;&nbsp;&nbsp;&nbsp;composer global require &quot;laravel/installer&quot;&nbsp;&nbsp;&nbsp;&nbsp;cd到$Home/.composer/vendor/bin目录下&nbsp;&nbsp;&nbsp;&nbsp;执行 Laravel new Blog&nbsp; 3.最后利用php的内置服务器&nbsp;&nbsp;&nbsp;&nbsp;php artisan serve一些收获&nbsp; &nbsp;1.Linux方面 .tar.gz通过的是源码安装 ./configure –prefix=/usr/local/php 即指定安装路径 卸载的时候只需要删除这个目录下的东西即可 开机自启动 增加环境变量&nbsp; &nbsp;2.php 的两种运行方式的php.ini有可能是不同的,也就是会出现你的web上面的phpinfo()和你直接用CLI执行的php -m发现扩展的开启情况是不相同的，这个时候就需要你运行CLI和web的时候所用的php.ini是同一个文件&nbsp; &nbsp;3.Laravel 从laraval知道了php有一个内置的服务器。]]></content>
      <tags>
        <tag>php</tag>
        <tag>laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装php扩展]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85PHP%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[下载扩展&nbsp;http://pecl.php.net/解压扩展 进入解压后的扩展目录 执行…/php/bin/phpize./configure –with-php-config=…/php/bin/php-config根据错误提示安装相应的依赖make &amp;&amp; make install在…/php/lib/extension/no-….目录下会出现.so的文件就说明安装好了到php.ini中增加extension=…/php/lib/ex…/xxx.so重启php]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则]]></title>
    <url>%2F2017%2F03%2F16%2F%E6%AD%A3%E5%88%99%E3%80%81mb_substr%2F</url>
    <content type="text"><![CDATA[0x1 爬虫过程遇到需要截取到&lt;span id=&quot;xhxm&quot;&gt;张三同学&lt;/span&gt;里面同学的名称&nbsp; 1.正则解决&nbsp; 2.通过字符串解决0x2 通过正则解决&nbsp; 1.简单解决&nbsp; &lt;span id=&quot;xhxm&quot;&gt;(.)\u540c\u5b66&lt;/span&gt;&nbsp;&nbsp; 2.零宽断言解决&nbsp; &nbsp;&gt;(.)(?=\u540c\u5b66)&nbsp;&nbsp;&nbsp; 这里使用零宽度正预测先行断言(?=exp)&nbsp; 就是找到匹配之前的内容&nbsp;&nbsp; (?&lt;=exp)用来找到匹配之后的东西，称为零宽度正回顾后发断言0x3 通过mb_substr解决 先匹配张三同学,然后截取字符串&nbsp; 因为这里的header是gb2312，所以指定mb_substr的编码为gb2312&nbsp; substr直接处理汉字会造成乱码的问题，可以使用mb_substr指定汉字编码方式gb2312&nbsp;&nbsp; 这样就可以截取到到张三0x4 这不算完&nbsp;]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat war]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E5%AE%89%E8%A3%85jdk%20tomcat%20.war%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[一、安装JDK 1.下载jdk，注意下载的时候不要下载成html了，这是个坑。。。2.vim /etc/profileJAVA_HOME=/usr/…/jdk解压后的路径PATH=$PATH:$JAVA_HOME/binCLASSPATH=.:$JAVA_HOME/lib/jt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH:wqsource /etc/profile最后java -version3.下载tomcat，解压进入目录/bin &nbsp; ./startup.sh4.eclipse export 项目为.war格式 选择导出路径 上传到服务器webapps目录下]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长不重复子串]]></title>
    <url>%2F2017%2F03%2F16%2F%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930package mainimport ( "fmt ")func maxLen(str string) int &#123; start := 0 maxlen := 0 lastO := make(map[rune]int) for i, v := range []rune(str) &#123; if lastI, ok := lastO[v]; ok &#123; start = lastI + 1 &#125; if (i-start+1 &amp;gt; maxlen) &#123; maxlen = i - start + 1 &#125; lastO[v] = i &#125; return maxlen&#125;func main() &#123; //求字符串最大不重复子串长度 //s:= "Yes哈哈哈! " fmt.Println(maxLen( "abcbcdef ")) fmt.Println(maxLen( "abcdef ")) fmt.Println(maxLen( "aaaaaaa ")) fmt.Println(maxLen( "你说什么 "))&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装php]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85PHP%2F</url>
    <content type="text"><![CDATA[1、&nbsp;&nbsp;安装依赖库2、&nbsp;&nbsp;yum install gd zlib libxml2 libxml2-devel libjpeg libjpeg-devel libpng libpng-devel3、&nbsp;&nbsp;下载php-5.6.23.tar.bz2，解压4、&nbsp;&nbsp;cd到php解压的目录里5、&nbsp;&nbsp;配置安装的一些参数./configure –prefix=/usr/local/php \–with-gd \–enable-gd-native-ttf \–enable-gd-jis-conv \–with-mysql=mysqlnd \–enable-mysqlnd \–with-pdo-mysql=mysqlnd \–enable-fpm\–with-openssl&nbsp;&nbsp;Curl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;./configure –prefix=/usr/local/php7 –with-gd –enable-gd-native-ttf –enable-gd-jis-conv –with-mysql=mysqlnd –enable-mysqlnd –with-pdo-mysql=mysqlnd –enable-fpm –with-openssl –enable-mbstring –enable-tokenizer –enable-zip –with-curl&nbsp;&nbsp;enable-fpm是让php作为独立的进程来运行，占用9000端口配置注意&nbsp;可能会报openssl的错误yum install openssl openssl-devel&nbsp;每个参数后的斜杠前是有空格的，斜杠所起的作用是连接上下两行，没有空格两个参数会连到一起就会报错了6、&nbsp;&nbsp;make &amp;&amp;make install这个过程中如果使用小内存的服务器可能出现php error，解决办法:在配置的最后一行加上–disable-fileinfo7、cd /usr/local/phpcp etc/php-fpm.conf.default etc/php-fpm.confcp /usr/local/src/php-5.5.13/php.ini-development ./lib/php.ini7、&nbsp;&nbsp;启动php./sbin/php-fpm&nbsp;&nbsp;/usr/local/php7/lib/php/extensions/no-debug-non-zts-20151012]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试算法题]]></title>
    <url>%2F2017%2F03%2F16%2F%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[package&nbsp;main import&nbsp;(&nbsp;&nbsp;&nbsp;&quot;fmt&quot;&nbsp;&nbsp;&nbsp;&quot;strconv&quot;&nbsp;&nbsp;&nbsp;&quot;sort&quot;) func&nbsp;filter(str&nbsp;string)&nbsp;string{&nbsp;&nbsp;&nbsp;//过滤aabbbbbccc&nbsp;为abc&nbsp;&nbsp;&nbsp;var&nbsp;newArr&nbsp;=&nbsp;make(map[rune]int)&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;&quot;&quot; &nbsp;&nbsp;&nbsp;for&nbsp;_,v&nbsp;:=&nbsp;range&nbsp;[]rune(str){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;newArr[v]&nbsp;==&nbsp;0{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr[v]&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;+=&nbsp;string(v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;return&nbsp;s} func&nbsp;filter2(str&nbsp;string)&nbsp;string{&nbsp;&nbsp;&nbsp;//过滤aaabbbcssss为3a3bc4s&nbsp;&nbsp;&nbsp;var&nbsp;newArr&nbsp;=&nbsp;make(map[rune]int)&nbsp;&nbsp;&nbsp;var&nbsp;sortArr&nbsp;[]string&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;&quot;&quot; &nbsp;&nbsp;&nbsp;for&nbsp;_,v&nbsp;:=&nbsp;range&nbsp;[]rune(str){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sortArr&nbsp;=&nbsp;append(sortArr,&nbsp;string(v))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;newArr[v]&nbsp;==&nbsp;0{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr[v]&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr[v]&nbsp;+=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;sort.Strings(sortArr) &nbsp;&nbsp;&nbsp;for&nbsp;i,v&nbsp;:=&nbsp;range&nbsp;newArr{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;==&nbsp;1&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;+=&nbsp;string(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;+=&nbsp;strconv.Itoa(v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;+=&nbsp;string(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;return&nbsp;s} func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;fmt.Println(filter2(&quot;aabccddee&quot;))}go语言的map用for range遍历是随机的key所以如果需要顺序遍历则需要先将key排序]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache]]></title>
    <url>%2F2017%2F03%2F16%2F%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85apache%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1.下载httpd apr apr-util pcre配置安装apr .configure –with-prefix=/…./apa/apr&nbsp;make &amp;&amp; make install配置安装apr-util .configure –with-prefix=/…./apa/apr-util&nbsp;make &amp;&amp; make install配置安装pcre .configure –with-prefix=/…./local/pcre&nbsp;make &amp;&amp; make install配置安装apache httpd&nbsp;./configure –prefix=/usr/local/apache2 –with-mpm=worker –enable-cache –enable-disk-cache –enable-mem-cache –enable-file-cache –enable-nonportable-atomics –enable-mods-shared=most –enable-so –enable-rewrite –enable-ssl –with-apr=/../apr安装目录 –with-apr-util=/…/apr-util安装目录 –with-pcre=pcre安装目录make &amp;&amp; make install&nbsp;php configure 参数 http://www.mamicode.com/info-detail-32029.html]]></content>
      <tags>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法]]></title>
    <url>%2F2017%2F03%2F16%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用四种基本的排序方法对生成的1000个随机数进行排序，比较执行时间一、冒泡排序123456789101112131415161718192021222324$s=microtime();//记录开始时间for($i=0;$i=1000;$i++)&#123; $a[$i] = mt_rand(0,1000);&#125;//冒泡排序for($j=0;$j&lt;999;$j++)&#123; for($k=0;$k&lt;999-$j;$k++)&#123; if($a[$k]&gt;$a[$k+1])&#123; $temp = $a[$k]; $a[$k] = $a[$k+1]; $a[$k+1] = $temp; &#125; &#125;&#125;for($i=0;$i&lt;1000;$i++)&#123; echo $a[$i].&apos;&apos;;&#125;$e = microtime();//记录结束时间echo &apos;&lt;br/&gt;&apos;;echo $e-$s; 二、简单选择排序123456789for($i=0;$i&lt;999;$i++)&#123; for($j=$i+1;$j&lt;1000;$j++)&#123; if($a[$j]&lt;$a[$i])&#123; $temp = $a[$j]; $a[$j] = $a[$i]; $a[$i] = $temp; &#125; &#125;&#125; 三、直接插入排序12345678910for($i=1;$i&lt;1000;$i++)&#123; if($a[$i]&lt;$a[$i-1])&#123; $j = $i-1; $temp = $a[$i]; for($j;$j&gt;=0&amp;amp;&amp;amp;$a[$j]&gt;$temp;$j--)&#123; $a[$j+1] = $a[$j]; &#125; $a[$j+1] = $temp; &#125;&#125; 四、快速排序123456789101112131415161718192021222324252627function qsort($left,$right)&#123; if($left&gt;$right)&#123; return; &#125; global $a; $i=$left; $j=$right; $key = $i; while($i&lt;$j)&#123; //从右往左找到第一个小于标记的值，交换 while($a[$j]&gt;=$a[$key]&amp;amp;&amp;amp;$j&gt;$i)$j--; $temp = $a[$i]; $a[$i] = $a[$j]; $a[$j] = $temp; $key = $j; //从左往右找到第一个大于标记的值，交换 while($a[$i]&lt;=$a[$key]&amp;amp;&amp;amp;$i&lt;$j)$i++; $temp = $a[$i]; $a[$i] = $a[$j]; $a[$j] = $temp; $key = $i;&#125;//递归调用qsort($left,$i-1);qsort($i+1,$right);qsort(0,999); 多次测试结果冒泡排序0.05~0.07 简单选择0.03~0.06 直接插入0.02~0.04 快速排序0.002~0.007]]></content>
      <tags>
        <tag>算法</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lnmp重启]]></title>
    <url>%2F2017%2F03%2F16%2FNginxPHPMysql%20%E9%87%8D%E5%90%AF%E7%AD%89%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[nginx&nbsp;&nbsp;&nbsp;start：&nbsp;/usr/local/nginx/sbin/nginx&nbsp;&nbsp;stop：&nbsp;/usr/local/nginx/sbin/nginx&nbsp;-s&nbsp;stop&nbsp;&nbsp;reload：&nbsp;/usr/local/nginx/sbin/nginx&nbsp;-s&nbsp;reload&nbsp;&nbsp;#**&nbsp;&nbsp;#php-fpm(fast-cgi)命令&nbsp;&nbsp;&nbsp;start：&nbsp;/usr/local/php/sbin/php-fpm&nbsp;&nbsp;stop：&nbsp;/bin/ps&nbsp;-ef&nbsp;|&nbsp;grep&nbsp;&#39;php-fpm&#39;&nbsp;|&nbsp;grep&nbsp;-v&nbsp;grep&nbsp;|&nbsp;cut&nbsp;-c&nbsp;9-15&nbsp;|&nbsp;xargs&nbsp;kill&nbsp;-9&nbsp;&nbsp;&nbsp;Linux：PHP&nbsp;5.3.3&nbsp;以上版本的php-fpm的重启&nbsp;INT,&nbsp;TERM：立刻终止QUIT：平滑终止USR1：重新打开日志文件USR2：平滑重载所有worker进程并重新载入配置和二进制模块&nbsp;示例：1）php-fpm&nbsp;关闭：kill&nbsp;-INT&nbsp;cat&amp;nbsp;/usr/local/php/var/run/php-fpm.pid&nbsp;2）php-fpm&nbsp;重启：kill&nbsp;-USR2&nbsp;cat&amp;nbsp;/usr/local/php/var/run/php-fpm.pid&nbsp;查看php-fpm进程数：ps&nbsp;aux&nbsp;|&nbsp;grep&nbsp;-c&nbsp;php-fpm&nbsp;#**&nbsp;&nbsp;#mysql命令&nbsp;&nbsp;start：&nbsp;/etc/init.d/mysqld&nbsp;start&nbsp;&nbsp;stop：&nbsp;/etc/init.d/mysqld&nbsp;stop&nbsp;&nbsp;restart：&nbsp;/etc/init.d/mysqld&nbsp;restart&nbsp;&nbsp;#**&nbsp;]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入]]></title>
    <url>%2F2017%2F03%2F16%2Fdependency-injection%2F</url>
    <content type="text"><![CDATA[依赖注入(DI)指的就是当你需要实例化的类依赖于其他类的实现的时候；不需要在本类中实例化所依赖的类，而是将所依赖的类通过参数的形式传入 即构造注入(构造函数)和设值注入(set方法);高耦合的反例//高耦合class Apple{​ protected $name = ‘ ‘; public function construct() { $this- &gt;name = ‘Apple ‘; } public function getName() { return $this- &gt;name; }}class Orange{​ protected $name = ‘ ‘; public function construct() { $this- &gt;name = ‘Orange ‘; } public function getName() { return $this- &gt;name; }}class Person{​ protected $likeFood = ‘ ‘; public function construct() { $this- &gt;likeFood = new Orange(); echo ‘这个人喜欢吃 ‘ . $this- &gt;likeFood- &gt;getName(); }}new Person();低耦合注入//低耦合实现interface Fruit{​ public function getName();}class Apple implements Fruit{​ protected $name = ‘ ‘; public function construct() { $this- &gt;name = ‘Apple ‘; } public function getName() { return $this- &gt;name; }}class Orange implements Fruit{​ protected $name = ‘ ‘; public function construct() { $this- &gt;name = ‘Orange ‘; } public function getName() { return $this- &gt;name; }}class Person{​ public $likeFood; public function construct(Fruit $fruit) { echo ‘这个人喜欢吃 ‘ . $fruit- &gt;getName(); }}$apple = new Apple();new Person($apple);]]></content>
      <tags>
        <tag>编程思想</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-7]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day2%2F</url>
    <content type="text"><![CDATA[7.&nbsp;Reverse Integerfunc&nbsp;reverse(x&nbsp;int)&nbsp;int&nbsp;{ s&nbsp;:=&nbsp;strconv.Itoa(x) rs&nbsp;:=&nbsp;&quot;&quot; j&nbsp;:=&nbsp;0 if&nbsp;x&nbsp;&lt;&nbsp;0&nbsp;{ j&nbsp;=&nbsp;1 rs&nbsp;+=&nbsp;&quot;-&quot; } for&nbsp;i&nbsp;:=&nbsp;len(s)&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;j;&nbsp;i–&nbsp;{ rs&nbsp;+=&nbsp;string(s[i]) } rsi,&nbsp;_&nbsp;:=&nbsp;strconv.Atoi(rs) if&nbsp;rsi&nbsp;&gt;&nbsp;(1&lt;&lt;31)&nbsp;||&nbsp;rsi&nbsp;&lt;&nbsp;-(1&nbsp;&lt;&lt;&nbsp;31)&nbsp;{ rsi&nbsp;=&nbsp;0 } return&nbsp;rsi}]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
