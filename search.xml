<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetcode-15]]></title>
    <url>%2F2019%2F05%2F24%2Fleetcode-15%2F</url>
    <content type="text"><![CDATA[leetcode-15给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。 注意：答案中不可以包含重复的三元组。 1234567例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，满足要求的三元组集合为：[ [-1, 0, 1], [-1, -1, 2]] 解答 123456789101112131415161718192021222324func threeSum(nums []int) [][]int &#123; sort.Ints(nums) len := len(nums) var res [][]int for i := 0; i &lt; len; i++ &#123; for j := 0; j &lt; len; j++ &#123; for k := 0; k &lt; len; k++ &#123; if nums[i]+nums[j]+nums[k] == 0 &#123; if i &lt; j &amp;&amp; j &lt; k &#123; tmpNums := make([]int, 3) tmpNums[0] = nums[i] tmpNums[1] = nums[j] tmpNums[2] = nums[k] res = append(res, tmpNums) if nums[i] == nums[i+1] &#123; i++ &#125; &#125; &#125; &#125; &#125; &#125; return res&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ubuntu]]></title>
    <url>%2F2019%2F05%2F24%2Fubuntu%2F</url>
    <content type="text"><![CDATA[淘汰笔记本的利用之前用的笔记本是dell5547，由于性能等各方面原因闲置下来了，当时还给它换了块固态硬盘，买的时候还是比较贵的，感觉扔了又比较可惜，于是打算安装个linux发行版在上面做服务器。 第一个问题是安装什么发行版本，centos还是ubuntu ​ 之前用过最多的还是centos这类的发行版，因为考虑到可以体验下gnome的桌面环境可以使用浏览器/phpstorm啥的再加上……(其实是因为安装centos遇到了显卡驱动的问题反正网上是这么说的，在安装系统时卡住了，搜了很多没有解决)。 ​ 对我而言redhat和debain系目前使用上最大的区别就是一个用yum来安装一个用apt-get。 下载Ubuntu 18.04.2 LTS (long time support?) 下载ultraiso 把系统写进u盘（第一步打开镜像iso文件 第二步写入硬盘），什么？要收费？试用30天！ 然后在笔记本开机的时候疯狂摁fn+f12（进入快捷选择启动盘），fn+f2进入boot引导设置界面.dell应该都是这样的，其他机型baidu/google.然后选择u盘，然后图形界面安装完成 ssh 12apt-get install openssh-serverservice ssh start 因为是用来作服务器，所以想让它启动就进入命令行模式 1234vim /etc/default/grub把这行 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;改成 GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash 3&quot;update-grub 重启进入命令行模式 然后把笔记本盖子关上（减小功耗），ssh断了??? 1234vim /etc/systemd/logind.conf HandleLidSwitch 这个变量是用来控制合上盖子的系统操作的 我们把它的值改成 &quot;lock&quot;(锁屏)systemctl restart systemd-logind 然后就可以让它安静地做一个服务器了，你可以在上面安装lnmp…… 最后一个问题，查看电量 1find /sys/ -name capacity -exec cat &#123;&#125; \;]]></content>
      <tags>
        <tag>ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql查询优化]]></title>
    <url>%2F2019%2F05%2F21%2Fmysql%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[mysql 查询优化一.使用explain分析sql索引使用情况有如下表结构 123456CREATE TABLE `index_test` ( `id` int(11) NOT NULL, `name` varchar(255) NOT NULL, `age` int(11) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 1explain SELECT * FROM `index_test` WHERE id = 1; id select_type table type possible_keys key key_len ref rows Extra 1 SIMPLE index_test const PRIMARY PRIMARY 4 const 1 id 唯一查询标识符 select_type SIMPLE/PRIMARY/UNION/SUBQUERY table 表名 type 类型 ​ The type column of EXPLAIN output describes how tables are joined. In JSON-formatted output,these are found as values of the access_type property. The following list describes the join types ​ 效率从高到低 1system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL ​ const 主键或者唯一索引的等值查询 ​ index 会扫描所有的索引 ​ ref 通过特殊查找(即不会扫描所有索引) ​ all 扫描全表 ​ EXPLAIN SELECT * FROM index_test where name like ‘%a%’; ​ range 范围查询 ​ EXPLAIN SELECT * FROM index_test where id &gt; 1; ​ EXPLAIN SELECT * FROM index_test where name like ‘a%’; possible_keys 能够用到的索引，但可能在具体查询时并没有用到 ​ eg:给上表再增加一个普通索引 ADD INDEX idx_name (name) ; 12EXPLAIN SELECT * FROM `index_test` where id = 1 and `name` = &apos;aaa&apos;;这里将会看到possible_keys为PRIMARY,idx_name，但实际上key为PRIMARY key 当前查询使用到的索引 key_len 索引使用的字节数 ​ 表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到. ref ​ The ref column shows which columns or constants are compared to the index named in the keycolumn to select rows from the table. rows 需要扫描的行数 ​ 在实际查询过程中，此值一般越小越好 Extra 额外 ​ 当所查询的字段在索引树上可以直接找到 会展示Using index 二.其他语句查询索引使用情况12show status like &apos;%Handler_read%&apos;;select * from schema_unused_indexes; 三.索引的最左匹配原则1.是什么 最左匹配是在复合索引中出现的概念 1ADD INDEX `idx_col1_col2_col3` (`col1`, `col2`, `col3`) ; 需要先使用最左边的索引才能继续使用第二个索引，以此类推 12345SELECT * FROM tbl_name WHERE col1=val1;SELECT * FROM tbl_name WHERE col1=val1 AND col2=val2;SELECT * FROM tbl_name WHERE col2=val2;SELECT * FROM tbl_name WHERE col2=val2 AND col3=val3; 上面四句sql,1,2句会用到索引，而3,4句不会用到。 至于条件先后，mysql会做查询优化 1234eg:explain SELECT * FROM `index_test` where age = 20 and `name` = &apos;ccc&apos;;explain SELECT * FROM `index_test` where `name` = &apos;ccc&apos; and age = 20;这两句sql的explain结果是一致的 2.为什么 mysql的B-tree索引树的数据结构决定了构建三个字段索引的时候只能保持第一个字段有序的时候才能保证第二个有序，然后才能保证第三个有序。 那是什么样的数据结构呢？ 结构猜想： 树的整棵索引树的根节点上是col1组成的B-tree树,当根节点的值相等的时候（也就是col1相等的时候）又会在此节点上再新建根节点是col2组成的B-tree树，以此类推，所以当有联合索引的查找开始的时候，先依据col1找到相对应的类似于子树的地方再根据col2,col3去查找，为什么这样就会快呢？因为在这样的树上查找到该节点的时候会用到的就是二分查找（折半查找 O(log2n)）。 有点类似于orderBy col1 orderBy col2 orderBy col3。 3.引申 复合索引：建立在多列上的索引 单列索引：建立在某一列上的索引 复合索引的 优点： 1.建立一个索引可以用于多处 （col1,col2）和 col1这种条件都能用到 缺点： 1.使用有局限性，最左匹配 2.插入数据后索引树建立相对单列索引肯定是更复杂的，整体而言占用的空间肯定也更大。 四.其他1.数据库三范式 1NF：每个列原子性/不可再分 2NF：非主键字段完全依赖于主键而不是依赖于主键的一部分 3NF : 非主键字段需要直接依赖于主键而不是间接依赖 2.临时表 3.filesort]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>索引</tag>
        <tag>优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel中的设计模式]]></title>
    <url>%2F2019%2F05%2F18%2FLaravel%E4%B8%AD%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Laravel中的设计模式一、外观/门面模式12为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层次的接口，使得子系统更加容易使用外部与子系统的通信是通过一个门面(Facade)对象进行 ​ 在laravel中，我们可以通过Log::info / Cache::add/Route::get这样的静态方法来记录日志或者新增缓存或者路由定义,这一类方法的调用都可以使用一致的静态方法调用方式来调用. 以Log::info为例的运行流程 config/app.php 123&apos;aliases&apos; =&gt; [ Log&apos; =&gt; Illuminate\Support\Facades\Log::class,] vendor/laravel/framework/src/Illuminate/Support/Facades/Log.php 12345678910111213141516171819&lt;?phpnamespace Illuminate\Support\Facades;/** * @see \Illuminate\Log\Writer */class Log extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return &apos;log&apos;; &#125;&#125; 从上面可以看到Log里面没有info这个静态方法，然后查看extends的Facade__callStatic()魔术方法 当被调用的对象没有这个static方法时就会先执行此方法 1234567891011121314151617181920212223public static function __callStatic($method, $args) &#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException(&apos;A facade root has not been set.&apos;); &#125; switch (count($args)) &#123; case 0: return $instance-&gt;$method(); case 1: return $instance-&gt;$method($args[0]); case 2: return $instance-&gt;$method($args[0], $args[1]); case 3: return $instance-&gt;$method($args[0], $args[1], $args[2]); case 4: return $instance-&gt;$method($args[0], $args[1], $args[2], $args[3]); default: return call_user_func_array([$instance, $method], $args); &#125; &#125; 那Log最终new的实例是什么呢 vendor/laravel/framework/src/Illuminate/Log/LogServiceProvider.php 12345678910111213141516171819202122232425262728293031/** * Register the service provider. * * @return void */public function register()&#123; $this-&gt;app-&gt;singleton(&apos;log&apos;, function () &#123; return $this-&gt;createLogger(); &#125;);&#125; /** * Create the logger. * * @return \Illuminate\Log\Writer */public function createLogger()&#123; $log = new Writer( new Monolog($this-&gt;channel()), $this-&gt;app[&apos;events&apos;] ); if ($this-&gt;app-&gt;hasMonologConfigurator()) &#123; call_user_func($this-&gt;app-&gt;getMonologConfigurator(), $log-&gt;getMonolog()); &#125; else &#123; $this-&gt;configureHandler($log); &#125; return $log;&#125; 最终调用到的就是 vendor/laravel/framework/src/Illuminate/Log/Writer.php 1234567891011/** * Log an informational message to the logs. * * @param string $message * @param array $context * @return void */public function info($message, array $context = [])&#123; return $this-&gt;writeLog(__FUNCTION__, $message, $context);&#125;]]></content>
      <tags>
        <tag>laravel</tag>
        <tag>设计模式</tag>
        <tag>编程思想</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[加密相关]]></title>
    <url>%2F2019%2F05%2F18%2F%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[加密相关一.对称加密1.使用相同的密钥来进行加密解密 2.优缺点：计算小、加密快/不够安全 3.eg: AES 二.非对称加密1.公钥和私钥 公钥加密私钥解密/私钥加密公钥解密 2.优缺点：安全性高/加解密时间长、速度慢 3.eg:RSA 三.签名/摘要eg:MD5 四.httpshttps使用对称加密和非对称加密同时使用集合两者优点]]></content>
      <tags>
        <tag>加密解密</tag>
        <tag>签名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[awk相关]]></title>
    <url>%2F2019%2F05%2F18%2Fawk%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[awk相关 统计nginx access_log中访问频率排前十的ip/URL etc awk ‘{print $1}’ access.log | sort | uniq -c | sort -nr -k1 | head -n 10 sort 让整个文件内容按行排序 相同内容的行会聚集到相邻的位置 uniq -c 去除重复列并且把重复次数产生新的一列展示到最前面 sort -nr -k1 把第一列的结果按照数字大小倒序排列 head -n 10 展示前十条 根据日志的格式调整print的列即可获取不同结果 列出当前目录下的所有文件 ls -lR |grep -v ^d|awk ‘{print $9}’ |tr -s ‘\n’]]></content>
      <tags>
        <tag>linux</tag>
        <tag>awk</tag>
        <tag>shell</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL存储引擎和索引结构]]></title>
    <url>%2F2019%2F04%2F25%2FMySQL%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%92%8C%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[一、数据结构 ​ MySQL的索引方法 B-tree 快速查找使用等于不等于条件或者范围（&gt;/&lt;/BETWEEN）条件的情形。 hash 只适用于MySQL的MEMORY存储引擎 二、MySQL （5.6为例）不同存储引擎的索引结构差别 ​ 这里讨论MySQL两种主要的存储引擎InnoDB 和 MyISAM InnoDB 每一个InnoDB都会有一个索引叫做聚集索引(clustered index)，通常这个索引也是主键（primary key），数据文件按主键聚集。每个索引的数据都会存在于此索引结构的树上。 每一个第二索引(Secondary Indexes)都会有一个字段来存储主键来关联上数据。 所有的InnoDB索引都是用B-trees,所有的索引记录都存在树的叶子结点。默认索引页大小为16KB。 MyISAM MySQL5.6版本之后默认存储引擎为InnoDB，如果需要MyISAM则需要在建表语句中指定。 同样支持B-tree索引、不支持聚集索引、不支持HASH索引。采用非聚集索引。 Primary Key和Secondary Key在结构上是一致的。MyISAM的索引文件不同之处在于Primary Key的key要求是唯一的，而Secondary Key的key可以重复。 和InnoDB的结构不同之处在于MyISAM的每个索引树的叶子节点存储的是数据的地址，索引文件数据文件分离。 三、BTREE树搜索算法 四、其他]]></content>
      <tags>
        <tag>mysql</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[redis-内存置换策略]]></title>
    <url>%2F2019%2F04%2F25%2Fredis-%E5%86%85%E5%AD%98%E7%BD%AE%E6%8D%A2%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[redis1.数据类型 ​ k-v string list set zset 2.redis内存淘汰策略 超出内存限制报错 淘汰最近最少未使用 从设置了过期时间中的键中淘汰最近最少未使用 随机淘汰 从设置了过期时间中的键中随机淘汰 淘汰离过期时间最近的键 3.redis 持久化策略]]></content>
      <tags>
        <tag>redis</tag>
        <tag>缓存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx-host]]></title>
    <url>%2F2019%2F04%2F16%2Fnginx%26%26host%2F</url>
    <content type="text"><![CDATA[记录一次奇怪的响应在本地调预发布的一个接口 search.xxx.bz的时候，总是出现一次响应正常一次不正常的现象/搜索无果 上服务器查找nginx配置 到conf目录 1find -type f -name &apos;*.conf&apos;|xargs grep &apos;search.xxx.bz&apos; 发现一个反向代理配置 123456789server &#123; listen 80; server_name search.tff.bz; location / &#123; proxy_set_header Host $proxy_host; proxy_pass http://search.sss.com; &#125;&#125; 1find -type f -name &apos;*.conf&apos;|xargs grep &apos;search.sss.com&apos; 正常nginx server 配置 12345678server &#123; listen 80; server_name search.services.sss.com; root /xxxx/public; access_log logs/search.sss.com.access.log main; error_log logs/search.sss.com.error.log; include laravel;&#125; 无异样 之前尝试过在本地ping search.sss.com 结果为127.0.0.1无异样 在机器上curl调接口也没问题 仔细检查host 发现有两个配置 search.sss.com 188.8.8.8 search.sss.com 127.0.0.1 猜想nginx 在反向代理解析host 的时候两次分别取了不同的host配置，屏蔽第一个，问题解决。]]></content>
      <tags>
        <tag>nginx</tag>
        <tag>host</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sphinx安装]]></title>
    <url>%2F2018%2F12%2F17%2FSphinx%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[坑1.安装Sphinx报错 1234567891011libsphinx.a(sphinx.o)：在函数‘xmlUnknownEncoding(void*, char const*, XML_Encoding*)’中：/mnt/Project/src/sphinx/src/sphinx.cpp:29116：对‘libiconv_open’未定义的引用libsphinx.a(sphinx.o)：在函数‘xmlUnknownEncoding(void*, char const*, XML_Encoding*)’中：sphinx.cpp:(.text+0x11ce)：对‘libiconv’未定义的引用sphinx.cpp:(.text+0x11ff)：对‘libiconv_close’未定义的引用collect2: 错误：ld 返回 1make[2]: *** [indexer] 错误 1make[2]: 离开目录“/mnt/Project/src/sphinx/src”make[1]: *** [all] 错误 2make[1]: 离开目录“/mnt/Project/src/sphinx/src”make: *** [all-recursive] 错误 1 以为是没有安装libiconv，yum安装还是报错 yum -y install libevent libevent-devel 百度 1.编译新增参数（注意这个改的是sphinx的解压包的src下的MakeFile）(推荐) ​ LIBS = -lm -lexpat -liconv -L/usr/local/lib 修改configure文件，找到“#define USE_LIBICONV 1”，将注释去掉，并将1改成0。 两个命令 12/usr/local/sphinx/bin/indexer --all //根据sphinx.conf的配置生成索引/usr/local/sphinx/bin/searchd //启动搜索引擎]]></content>
      <tags>
        <tag>sphinx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Sphinx 2.2.6-release 参考手册]]></title>
    <url>%2F2018%2F12%2F16%2FSphinx%2F</url>
    <content type="text"><![CDATA[Sphinx 2.2.11-release 参考手册免费的开源SQL全文搜索引擎 Copyright © 2001-2014 Andrew Aksyonoff Copyright © 2008-2014 Sphinx Technologies Inc, http://sphinxsearch.com 翻译校对 Czhuyu 第一章. 介绍1.1. 关于sphinx 是一个全文搜索引擎，公开发行于GPL 2.0，商业许可(例如 用于嵌入式)通过需要许可。 从技术上讲，Sphinx是一个独立的软件包提供快速的全文搜索功能的客户端软件。它特意被设计为跟SQL 数据库一体的去存储数据，并且可以简单地通过脚本语言连接。总之，Sphinx不依赖于任何特殊的数据库功能。 应用程序可以通过Sphinx的搜索守护进程searchd用以下三种连接方式：a)通过Sphinx自己实现的Mysql的网络协议(使用的一个小的SQL的子集叫做SphinxQL，这是推荐的方式)，b)通过自带的search API(SphinxAPI)或者c)通过Mysql服务的可插拔的存储引擎(SphinxSE)。 官方的原生SphinxAPI实现了PHP,Perl,Python,Ruby和Java在贡献的包里。API是非常轻量级的所以实现一个新的语言的API只需要几个小时就行。 从1.10的beta版本开始，Sphinx支持两种不同的后台索引：磁盘后台索引和实时后台索引。磁盘索引支持在线的全文索引重建，但是在线更新只支持非text的(属性)数据。实时索引支持在线的全文索引更新。上个版本只在磁盘索引中支持。 数据可以加载进磁盘索引用一个所以叫数据源。建立源可以直接从MySQL，PostgreSQL，MSSQL，ODBC compliant 数据库(Oracle等等)或者一个管道在TSV或者一个格式化的XML。新增一个数据源驱动被设计得经可能简单。实时索引，直到1.10beta版本为止，只能用SphinxQL。 就像名字一样，Sphinx是SQL Phrase Index译解缩写。是的，我知道关于CMU的Sphinx项目。 1.2. Sphinx特性Sphinx特性的关键是 索引和搜索的高性能 先进的索引和查询工具(灵活的并且富有特性的文本分词器,查询语言，几个不同的排名模式，等等); 先进的结果集后处理（SELECT表达式，WHERE,ORDER BY,GROUP BY,HAVING等在文本搜索中） 可扩展的久经考验地用于数十亿的文档，万亿字节的数据，每秒成千上万的请求。 方便的集合SQL和XML的数据源，和SphinxQL，SphinxAPI,和SphinxSE搜索接口； 简单的可伸缩分布式搜索。 扩大一点，Sphinx： 拥有很高的索引速度(达到 10-15MB/每秒每个核心在内部基准上)； 拥有很高的搜索速度（达到150-250/每秒每个核心对阵1,000,000文档，1.2G的数据在内部基准上） 拥有很高的扩展性(最大的已知的聚集索引超过了3,000,000,000文档，并且最繁忙的巅峰达到了500万次查询每天) 2.2. 编译安装Sphinx2.2.1 需要的工具在unix上，你需要下面的工具来建立和安装Sphinx 一个用来工作的c++的编译器，GNU gcc和clang是知名的用来工作。 一个好的make工具，GNU很出名用来工作 在windows上面，你会需要Microsoft Visual C/C++ Studio .Net 2005 或者以上。其他的编译器/环境也是一样的工作，但目前，你需要手动建立make文件(或者其他环境的特定项目文件) 2.2.2. 在Linux上编译安装2.6. Sphinx 废弃项目和更改默认的配置在2.2.1-beta版本我们决定开始去除一些老的功能，所有的非官方的弃用一段时间。现在我们正式通知你们关于它们。 修改如下： 32位的文档id已经被废弃了。我们的二进制发行版本现在默认都在64位的documentid的基础上建立。需要注意的是它们仍然可以用32位ID索引，但是这个支持最后会被移除。事实上，它前一阵子已经被废弃了，但是现在我们只想清除它。我们没有看到用这种方式来节省服务器RAM的任何意义。 dict=crc现在已经被废弃了。它是一大串约束。最重要的一个是关键词碰撞，并且没有通配符匹配支持。你可以获取更多的有关这些约束从我们的文档。2.7 第三章.索引3.1. 数据源需要被索引的数据可以来自非常不同的源：数据库，简单的文本数据，HTMl文件，邮箱等等。从Sphinx的视角看来，数据的索引是一个结构化文档的合集，每一个合集都会有相同的字段和属性。这一点和SQL相似的地方是每一个SQL的行对应一个文档，每一个列对应文档的字段或者属性。 由于Sphinx获得的不同的数据来源，需要不同的代码去取得数据然后准备索引。这些代码被称为数据源驱动（简单的说叫驱动或者叫数据源）. 在写这个文档的时候，现有的驱动有MySQL，PostgreSQL,MS SQL(on Windows),和ODBC.也有一类驱动叫做xmlpipe2，特殊的运行在命令行并且获取数据从它的标准输出中。看3.9 “xmlpipe2 数据源” 章节获取更多信息。在2.2.1的beta版本中tsvpipe和csvpipe数据源也搅入了进来。你可以获取更多信息从3.10”tsvpipe\csvpipe(Tab\Comma Separated Values)数据源” 索引有很多的数据来源。他们会有序地依照索引的定义规定通过非常相同的流程。所有的文档从这些源产生的灰合并起来就行他们来自单一的数据源。 3.2.全文本字段全文本字段（或者简单说是字段）是文本的内容被Sphinx索引，并且可以（快速地）被关键字搜索。 字段可以被命名，并且你可以限制你的搜索为一个字段（例如. 只通过”title”） 或者字段的子集（例如”title”和”abstract”）.Sphinx索引支持最大256个字段。但是，在2.0.1-beta版本索引被限制到了32个字段，因为并发在匹配引擎。完全的支持到256个字段在2.0.2-beta版本。 需要注意的是字段的源内容不会存储到sphinx中。你给Sphinx的文本，全文本索引（一个特殊的数据结构能够快速地被关键字搜索）建立来自于此文本。但是源文本会被丢弃掉。Sphinx假定你已经把这些内容保存到了其他的任何地方。 还有要说的是，不可能对源文本进行完全的结构重建，因为一些特殊的空格，大小写，标点符号会被丢失在索引的时候。理论上来说只有部分的被结构重建在文本里面，但是这将是一个十分缓慢的过程（尤其是如果CRC字典被使用，甚至不是保存关键字而是它们的hash） 3.3. 属性属性是每个文档关联的额外的值用来完成额外的过滤和排序在搜索过程中。 它经常被用于额外的全文索引结果基础不仅是匹配文档ID，rank，而且是其他的每个文档的值。举个例子，有可能需要用日期排序，然后是相关性，或者你需要用指定的价格区间搜索产品，或者筛选出某个作者的文章在你的博客里，或者按月分组。为了有效地做上面的这些事情，Sphinx允许附加一定数量的额外属性为每个文档，并且存储它们的值在全文本中，然后使用存储的值去过滤，排序，分组全文本匹配到的结果就变成了可能。 属性，不同于字段，不是全文索引。它们存储在索引中，但是他们不能当作全文本进行搜索，企图这样做会导致错误。 例如，不可能使用匹配表达式@column 1去匹配column为1的文档。如果column是一个熟悉，并且忽略搜索关联性工具。此外，属性返回的结果来自search daemon,而不是索引文本。 一个比较好的例子就是论坛讨论帖子的表。假定只需要标题和内容去搜索-但是有时候也需要搜索通过作者个子讨论（例如xxxxx）；或者给匹配到的结果按照post_date排序；或者用post_date按月份分组并计算每个组匹配的条数。 这个可以获得说明所有的提及的列（除了标题和内容，它们是全文本字段）作为属性，索引它们，然后用API调用设置过滤器，排序和分组。这里是一个例子。 Example sphinx.conf part: 1234567...sql_query = SELECT id, title, content, \ author_id, forum_id, post_date FROM my_forum_postssql_attr_uint = author_idsql_attr_uint = forum_idsql_attr_timestamp = post_date... Example application code (in PHP) 12345678// only search posts by author whose ID is 123$cl-&gt;SetFilter ( &quot;author_id&quot;, array ( 123 ) );// only search posts in sub-forums 1, 3 and 7$cl-&gt;SetFilter ( &quot;forum_id&quot;, array ( 1,3,7 ) );// sort found posts by posting date in descending order$cl-&gt;SetSortMode ( SPH_SORT_ATTR_DESC, &quot;post_date&quot; ); 第四章. 实时索引实时索引是一个新的后台让你新增，更新，或者删除文档在飞速中。实时索引在1.10-beta中加入。当你需要查询实时索引的时候你可以使用SphinxAPI,SphinxQL,或者SphinxSE，更新他们只可能通过SphinxQL在现在。完整的SphinxQL参考在第八张章节。 4.1. 实时索引概览实时索引应该声明在sphinx.conf，就像所有的其他索引类型一样。]]></content>
      <tags>
        <tag>sphinx</tag>
        <tag>搜索引擎</tag>
        <tag>翻译</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F12%2F07%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
  <entry>
    <title><![CDATA[Cookie && Session]]></title>
    <url>%2F2018%2F03%2F16%2FCookie%E5%92%8CSession%2F</url>
    <content type="text"><![CDATA[Cookie &amp;&amp; Session一、cookie 定义: 是一种在浏览器端储存数据并以此来跟踪和识别用户的机制，是http头的一部分 使用方法:设置cookie函数原型: 1setcookie ( string $name [, string $value = &quot;&quot; [, int $expire = 0 [, string $path = &quot;&quot; [, string $domain = &quot;&quot; [, bool $secure = false [, bool $httponly = false ]]]]]] ) : bool setcookie() 定义了 Cookie，会和剩下的 HTTP 头一起发送给客户端。 和其他 HTTP 头一样，必须在脚本产生任意输出之前发送 Cookie（由于协议的限制）。 请在产生任何输出之前（包括 和 或者空格）调用本函数。 expire以秒为单位，设置一个小时的有效期即是time()+3600 一旦设置 Cookie 后，下次打开页面时可以使用 $_COOKIE 读取。 Cookie 值同样也存在于 $_REQUEST。 服务器端通过http头将cookie的信息传递到客户端里面包括了cookie的内容和生存时间 清除cookie 如果未设置cookie有效期，默认情况下cookie在浏览器关闭时会清除，如果设置了有效期且想提前结束采用如下方法。 1setcookie( ‘name ‘, ‘zhangsan ‘,time()-1);||unset($_COOKIE[ ‘name ‘]); 二、session 定义在并发访问时由一个方法来保存某些数据.从而使你能够构建更多的定制程序 从而提高你的 web 网站的吸引力一个访问者访问你的 web 网站将被分配一个唯一的 id, 就是所谓的会话 id. 这个 id 可以存储在用户端的一个cookie中，也可以通过 URL 进行传递 使用方法Example #1 page1.php 1234567891011121314151617&lt;?php// page1.phpsession_start();echo &apos;Welcome to page #1&apos;;$_SESSION[&apos;favcolor&apos;] = &apos;green&apos;;$_SESSION[&apos;animal&apos;] = &apos;cat&apos;;$_SESSION[&apos;time&apos;] = time();// 如果使用 cookie 方式传送会话 IDecho &apos;&lt;br /&gt;&lt;a href=&quot;page2.php&quot;&gt;page 2&lt;/a&gt;&apos;;// 如果不是使用 cookie 方式传送会话 ID，则使用 URL 改写的方式传送会话 IDecho &apos;&lt;br /&gt;&lt;a href=&quot;page2.php?&apos; . SID . &apos;&quot;&gt;page 2&lt;/a&gt;&apos;;?&gt; 请求 page1.php 页面之后， 第二个页面 page2.php 会包含会话数据。 请查阅 会话参考 获取更多关于 会话 ID 传送的信息， 在该参考页面中有关于常量 SID 的详细说明。 Example #2 page2.php 1234567891011121314&lt;?php// page2.phpsession_start();echo &apos;Welcome to page #2&lt;br /&gt;&apos;;echo $_SESSION[&apos;favcolor&apos;]; // greenecho $_SESSION[&apos;animal&apos;]; // catecho date(&apos;Y m d H:i:s&apos;, $_SESSION[&apos;time&apos;]);// 类似 page1.php 中的代码，你可能需要在这里处理使用 SID 的场景echo &apos;&lt;br /&gt;&lt;a href=&quot;page1.php&quot;&gt;page 1&lt;/a&gt;&apos;;?&gt;]]></content>
      <tags>
        <tag>http</tag>
        <tag>cookie</tag>
        <tag>session</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat war]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E5%AE%89%E8%A3%85jdk%20tomcat%20.war%E5%8F%91%E5%B8%83%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[一、安装JDK 1.下载jdk，注意下载的时候不要下载成html了，这是个坑。。。2.vim /etc/profileJAVA_HOME=/usr/…/jdk解压后的路径PATH=$PATH:$JAVA_HOME/binCLASSPATH=.:$JAVA_HOME/lib/jt.jar:$JAVA_HOME/lib/tools.jarexport JAVA_HOME PATH CLASSPATH:wqsource /etc/profile最后java -version3.下载tomcat，解压进入目录/bin &nbsp; ./startup.sh4.eclipse export 项目为.war格式 选择导出路径 上传到服务器webapps目录下]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装mysql]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Mysql%2F</url>
    <content type="text"><![CDATA[1、mysql 官网下载适合的压缩包，格式为mysql-x.x.xx-linuxxxx.tar.gz2、解压后配置配置帮助 ./configure –help3、groupadd mysqluseradd –g mysql mysqlcd到mysql的解压目录chown –R mysql .chgrp –R mysql .4、./scripts/mysql_install_db –user=mysql如果提示laibaio.1的相关错误yum install libaioso.1 libaio5、把目录权限还给rootchown –R root .chown –R mysql datamkdir /var/run/mysqldchown mysql /var/run/mysqldchgrp mysql /var/run/mysqld6、启动mysql./bin/mysqld_safe –user=mysql &amp;7、连接mysql ./bin/mysql –uroot -p如果报错 建立软连接或者直接将sock文件复制过去建立软连接方法ln /var/lib/mysql/mysql.sock /tmp/mysql.sock8、修改密码update user set Password=password(你想要的密码) where Host=’localhost’ and User= ‘root ‘;delete from user where Password= ‘’;flush privileges;]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入]]></title>
    <url>%2F2017%2F03%2F16%2Fdependency-injection%2F</url>
    <content type="text"><![CDATA[依赖注入(DI)指的就是当你需要实例化的类依赖于其他类的实现的时候；不需要在本类中实例化所依赖的类，而是将所依赖的类通过参数的形式传入 即构造注入(构造函数)和设值注入(set方法);高耦合的反例//高耦合class Apple{​ protected $name = ‘ ‘; public function construct() { $this- &gt;name = ‘Apple ‘; } public function getName() { return $this- &gt;name; }}class Orange{​ protected $name = ‘ ‘; public function construct() { $this- &gt;name = ‘Orange ‘; } public function getName() { return $this- &gt;name; }}class Person{​ protected $likeFood = ‘ ‘; public function construct() { $this- &gt;likeFood = new Orange(); echo ‘这个人喜欢吃 ‘ . $this- &gt;likeFood- &gt;getName(); }}new Person();低耦合注入//低耦合实现interface Fruit{​ public function getName();}class Apple implements Fruit{​ protected $name = ‘ ‘; public function construct() { $this- &gt;name = ‘Apple ‘; } public function getName() { return $this- &gt;name; }}class Orange implements Fruit{​ protected $name = ‘ ‘; public function construct() { $this- &gt;name = ‘Orange ‘; } public function getName() { return $this- &gt;name; }}class Person{​ public $likeFood; public function construct(Fruit $fruit) { echo ‘这个人喜欢吃 ‘ . $fruit- &gt;getName(); }}$apple = new Apple();new Person($apple);]]></content>
      <tags>
        <tag>编程思想</tag>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装php扩展]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85PHP%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[下载扩展&nbsp;http://pecl.php.net/解压扩展 进入解压后的扩展目录 执行…/php/bin/phpize./configure –with-php-config=…/php/bin/php-config根据错误提示安装相应的依赖make &amp;&amp; make install在…/php/lib/extension/no-….目录下会出现.so的文件就说明安装好了到php.ini中增加extension=…/php/lib/ex…/xxx.so重启php]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装nginx]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85Nginx%2F</url>
    <content type="text"><![CDATA[到nginx.org下载wget http://nginx.org/download/nginx-1.10.0.tar.gz解压压缩包环境配置Cd到解压出来的nginx目录中有configure目录的地方进行环境配置./configure –prefix=/usr/local/nginxⅠ.如果遇到提示缺少pcre库到www.pcre.org下载pcre库，if解压到/usr/local/src/pcre-sourceⅡ.1.6版本以后的版本制定pcre源码目录./configure –prefix=/usr/local/nginx–with-pcre=/usr/local/src/pcre-source之前的版本制定安装目录./configure –prefix=/usr/local/nginx–with-pcre=/usr/pcre4.编译安装 make &amp;&amp; make install5.启动nginx ./sbin/nginx重启./sbin/nginx –s reloadException:如果遇到80端口被httpd(Apache)占了Pkill -9 httpd如果无法访问检查防火墙设置]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP OPTIONS]]></title>
    <url>%2F2017%2F03%2F16%2FHTTP%20OPTIONS%2F</url>
    <content type="text"><![CDATA[幂等和非幂等 执行一次和执行很多次同样的操作是否是一样的 GET/PUT/DELETE 幂等 POST 非幂等]]></content>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-7]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day2%2F</url>
    <content type="text"><![CDATA[7.&nbsp;Reverse Integerfunc&nbsp;reverse(x&nbsp;int)&nbsp;int&nbsp;{ s&nbsp;:=&nbsp;strconv.Itoa(x) rs&nbsp;:=&nbsp;&quot;&quot; j&nbsp;:=&nbsp;0 if&nbsp;x&nbsp;&lt;&nbsp;0&nbsp;{ j&nbsp;=&nbsp;1 rs&nbsp;+=&nbsp;&quot;-&quot; } for&nbsp;i&nbsp;:=&nbsp;len(s)&nbsp;-&nbsp;1;&nbsp;i&nbsp;&gt;=&nbsp;j;&nbsp;i–&nbsp;{ rs&nbsp;+=&nbsp;string(s[i]) } rsi,&nbsp;_&nbsp;:=&nbsp;strconv.Atoi(rs) if&nbsp;rsi&nbsp;&gt;&nbsp;(1&lt;&lt;31)&nbsp;||&nbsp;rsi&nbsp;&lt;&nbsp;-(1&nbsp;&lt;&lt;&nbsp;31)&nbsp;{ rsi&nbsp;=&nbsp;0 } return&nbsp;rsi}]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-4]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day5%2F</url>
    <content type="text"><![CDATA[3.&nbsp;Longest Substring Without Repeating CharactersGiven a string, find the length of the&nbsp;longest substring&nbsp;without repeating characters.Examples:Given&nbsp;&quot;abcabcbb&quot;, the answer is&nbsp;&quot;abc&quot;, which the length is 3.Given&nbsp;&quot;bbbbb&quot;, the answer is&nbsp;&quot;b&quot;, with the length of 1.Given&nbsp;&quot;pwwkew&quot;, the answer is&nbsp;&quot;wke&quot;, with the length of 3. Note that the answer must be a&nbsp;substring,&nbsp;&quot;pwke&quot;&nbsp;is a&nbsp;subsequence&nbsp;and not a substring.func&nbsp;lengthOfLongestSubstring(s&nbsp;string)&nbsp;int&nbsp;{ arr&nbsp;:=&nbsp;make(map[rune]int) start&nbsp;:=&nbsp;0 maxlen&nbsp;:=&nbsp;0 for&nbsp;i,&nbsp;v&nbsp;:=&nbsp;range&nbsp;[]rune(s)&nbsp;{ if&nbsp;pre,&nbsp;ok&nbsp;:=&nbsp;arr[v];&nbsp;ok&nbsp;&amp;&amp;&nbsp;pre&nbsp;&gt;=&nbsp;start&nbsp;{ start&nbsp;=&nbsp;pre&nbsp;+&nbsp;1 } if&nbsp;i-start+1&nbsp;&gt;&nbsp;maxlen&nbsp;{ maxlen&nbsp;=&nbsp;i&nbsp;-&nbsp;start&nbsp;+&nbsp;1 } arr[v]&nbsp;=&nbsp;i } return&nbsp;maxlen}]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[day3]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day3%2F</url>
    <content type="text"><![CDATA[Binary Tree (Traverse A Tree)Binary Tree Preorder Traversal/*&nbsp;&nbsp;Definition&nbsp;for&nbsp;a&nbsp;binary&nbsp;tree&nbsp;node.&nbsp;&nbsp;type&nbsp;TreeNode&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Val&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left&nbsp;TreeNode&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right&nbsp;TreeNode&nbsp;&nbsp;}&nbsp;/func&nbsp;preorderTraversal(root&nbsp;TreeNode)&nbsp;[]int&nbsp;{ var&nbsp;arr&nbsp;[]int if&nbsp;root&nbsp;==&nbsp;nil&nbsp;{ return&nbsp;arr } arr&nbsp;=&nbsp;append(arr,&nbsp;root.Val) arr1&nbsp;:=&nbsp;preorderTraversal(root.Left) arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr1) arr2&nbsp;:=&nbsp;preorderTraversal(root.Right) arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr2) return&nbsp;arr}func&nbsp;arrmerge(arr&nbsp;[]int,&nbsp;arr1&nbsp;[]int)&nbsp;[]int&nbsp;{​ for&nbsp;_,&nbsp;v&nbsp;:=&nbsp;range&nbsp;arr1&nbsp;{​ arr&nbsp;=&nbsp;append(arr,&nbsp;v)​ }​ return&nbsp;arr}Binary Tree Inorder Traversalfunc&nbsp;inorderTraversal(root&nbsp;TreeNode)&nbsp;[]int&nbsp;{​ var&nbsp;arr&nbsp;[]int​ if&nbsp;root&nbsp;==&nbsp;nil&nbsp;{​ return&nbsp;arr​ }​ arr1&nbsp;:=&nbsp;inorderTraversal(root.Left)​ arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr1)​ arr&nbsp;=&nbsp;append(arr,&nbsp;root.Val)​ arr2&nbsp;:=&nbsp;inorderTraversal(root.Right)​ arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr2)​ return&nbsp;arr}Binary Tree Postorder Traversalfunc&nbsp;postorderTraversal(root&nbsp;*TreeNode)&nbsp;[]int&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;var&nbsp;arr&nbsp;[]int​ if&nbsp;root&nbsp;==&nbsp;nil&nbsp;{​ return&nbsp;arr​ }​ arr1&nbsp;:=&nbsp;postorderTraversal(root.Left)​ arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr1)​ arr2&nbsp;:=&nbsp;postorderTraversal(root.Right)​ arr&nbsp;=&nbsp;arrmerge(arr,&nbsp;arr2)&nbsp;&nbsp;&nbsp;&nbsp;arr&nbsp;=&nbsp;append(arr,&nbsp;root.Val)​ return&nbsp;arr}&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux安装php]]></title>
    <url>%2F2017%2F03%2F16%2FLinux%E4%B8%8B%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85PHP%2F</url>
    <content type="text"><![CDATA[1、&nbsp;&nbsp;安装依赖库2、&nbsp;&nbsp;yum install gd zlib libxml2 libxml2-devel libjpeg libjpeg-devel libpng libpng-devel3、&nbsp;&nbsp;下载php-5.6.23.tar.bz2，解压4、&nbsp;&nbsp;cd到php解压的目录里5、&nbsp;&nbsp;配置安装的一些参数./configure –prefix=/usr/local/php \–with-gd \–enable-gd-native-ttf \–enable-gd-jis-conv \–with-mysql=mysqlnd \–enable-mysqlnd \–with-pdo-mysql=mysqlnd \–enable-fpm\–with-openssl&nbsp;&nbsp;Curl &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;./configure –prefix=/usr/local/php7 –with-gd –enable-gd-native-ttf –enable-gd-jis-conv –with-mysql=mysqlnd –enable-mysqlnd –with-pdo-mysql=mysqlnd –enable-fpm –with-openssl –enable-mbstring –enable-tokenizer –enable-zip –with-curl&nbsp;&nbsp;enable-fpm是让php作为独立的进程来运行，占用9000端口配置注意&nbsp;可能会报openssl的错误yum install openssl openssl-devel&nbsp;每个参数后的斜杠前是有空格的，斜杠所起的作用是连接上下两行，没有空格两个参数会连到一起就会报错了6、&nbsp;&nbsp;make &amp;&amp;make install这个过程中如果使用小内存的服务器可能出现php error，解决办法:在配置的最后一行加上–disable-fileinfo7、cd /usr/local/phpcp etc/php-fpm.conf.default etc/php-fpm.confcp /usr/local/src/php-5.5.13/php.ini-development ./lib/php.ini7、&nbsp;&nbsp;启动php./sbin/php-fpm&nbsp;&nbsp;/usr/local/php7/lib/php/extensions/no-debug-non-zts-20151012]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次完整的请求过程]]></title>
    <url>%2F2017%2F03%2F16%2F%E4%B8%80%E6%AC%A1%E5%AE%8C%E6%95%B4%E7%9A%84%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[浏览器一次完整的请求过程]]></content>
      <tags>
        <tag>http</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-2]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day4%2F</url>
    <content type="text"><![CDATA[2.&nbsp;Add Two NumbersYou are given two&nbsp;non-empty&nbsp;linked lists representing two non-negative integers. The digits are stored in&nbsp;reverse order&nbsp;and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.ExampleInput:&nbsp;(2&nbsp;-&gt;&nbsp;4&nbsp;-&gt;&nbsp;3)&nbsp;+&nbsp;(5&nbsp;-&gt;&nbsp;6&nbsp;-&gt;&nbsp;4)Output:&nbsp;7&nbsp;-&gt;&nbsp;0&nbsp;-&gt;&nbsp;8Explanation:&nbsp;342&nbsp;+&nbsp;465&nbsp;=&nbsp;807./*&nbsp;&nbsp;Definition&nbsp;for&nbsp;singly-linked&nbsp;list.&nbsp;&nbsp;type&nbsp;ListNode&nbsp;struct&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Val&nbsp;int&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Next&nbsp;ListNode&nbsp;&nbsp;}&nbsp;/func&nbsp;addTwoNumbers(l1&nbsp;ListNode,&nbsp;l2&nbsp;ListNode)&nbsp;ListNode&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;i1&nbsp;:=&nbsp;0 i2&nbsp;:=&nbsp;0 p&nbsp;:=&nbsp;l1 j&nbsp;:=&nbsp;0 for&nbsp;{ if&nbsp;p&nbsp;!=&nbsp;nil&nbsp;{ i1&nbsp;+=&nbsp;p.Val&nbsp;&nbsp;int(math.Pow(float64(10),&nbsp;float64(j))) j++ p&nbsp;=&nbsp;p.Next }&nbsp;else&nbsp;{ break } } j&nbsp;=&nbsp;0 p&nbsp;=&nbsp;l2 for&nbsp;{ if&nbsp;p&nbsp;!=&nbsp;nil&nbsp;{ i2&nbsp;+=&nbsp;p.Val&nbsp;&nbsp;int(math.Pow(float64(10),&nbsp;float64(j))) j++ p&nbsp;=&nbsp;p.Next }&nbsp;else&nbsp;{ break } } revres&nbsp;:=&nbsp;i1&nbsp;+&nbsp;i2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fmt.Println(revres) head&nbsp;:=&nbsp;new(ListNode) p&nbsp;=&nbsp;head for&nbsp;{ if&nbsp;revres&nbsp;==&nbsp;0&nbsp;{ break }&nbsp;else&nbsp;{ p.Val&nbsp;=&nbsp;revres&nbsp;%&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; revres&nbsp;=&nbsp;revres&nbsp;/&nbsp;10&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;revres&nbsp;!=&nbsp;0{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;node&nbsp;:=&nbsp;new(ListNode) &nbsp;&nbsp;&nbsp;&nbsp;p.Next&nbsp;=&nbsp;node &nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;p.Next&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} } }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;p&nbsp;=&nbsp;l1 for&nbsp;{ if&nbsp;p.Next&nbsp;==&nbsp;nil&nbsp;{ break } fmt.Printf(&quot;%d\t&quot;,&nbsp;p.Val) p&nbsp;=&nbsp;p.Next }&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return&nbsp;head&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp; 后面出现了位数很长的用例，所以换成采用数组来暂存单链表func&nbsp;addTwoNumbers(l1&nbsp;ListNode,&nbsp;l2&nbsp;ListNode)&nbsp;ListNode&nbsp;{ var&nbsp;i1&nbsp;[]int var&nbsp;i2&nbsp;[]int p&nbsp;:=&nbsp;l1 for&nbsp;{ if&nbsp;p&nbsp;!=&nbsp;nil&nbsp;{ i1&nbsp;=&nbsp;append(i1,&nbsp;p.Val) p&nbsp;=&nbsp;p.Next }&nbsp;else&nbsp;{ break } } p&nbsp;=&nbsp;l2 for&nbsp;{ if&nbsp;p&nbsp;!=&nbsp;nil&nbsp;{ i2&nbsp;=&nbsp;append(i2,&nbsp;p.Val) p&nbsp;=&nbsp;p.Next }&nbsp;else&nbsp;{ break } } head&nbsp;:=&nbsp;new(ListNode) p&nbsp;=&nbsp;head lenthi1&nbsp;:=&nbsp;len(i1) lenthi2&nbsp;:=&nbsp;len(i2) if&nbsp;lenthi1&nbsp;!=&nbsp;lenthi2&nbsp;{ if&nbsp;lenthi1&nbsp;&lt;&nbsp;lenthi2&nbsp;{ for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;lenthi2-lenthi1;&nbsp;i++&nbsp;{ i1&nbsp;=&nbsp;append(i1,&nbsp;0) } }&nbsp;else&nbsp;{ for&nbsp;i&nbsp;:=&nbsp;0;&nbsp;i&nbsp;&lt;&nbsp;lenthi1-lenthi2;&nbsp;i++&nbsp;{ i2&nbsp;=&nbsp;append(i2,&nbsp;0) } } } lenthi1&nbsp;=&nbsp;len(i1) lenthi2&nbsp;=&nbsp;len(i2) flag&nbsp;:=&nbsp;0 for&nbsp;i,&nbsp;_&nbsp;:=&nbsp;range&nbsp;i1&nbsp;{ sum&nbsp;:=&nbsp;i1[i]&nbsp;+&nbsp;i2[i] if&nbsp;i&nbsp;&lt;&nbsp;lenthi1-1&nbsp;{ if&nbsp;(sum)/10&nbsp;&gt;&nbsp;0&nbsp;{ i1[i+1]&nbsp;+=&nbsp;1 } }&nbsp;else&nbsp;{ if&nbsp;(sum)/10&nbsp;&gt;&nbsp;0&nbsp;{ flag&nbsp;=&nbsp;1 } } p.Val&nbsp;=&nbsp;sum&nbsp;%&nbsp;10 if&nbsp;i&nbsp;&lt;&nbsp;lenthi1-1&nbsp;{ node&nbsp;:=&nbsp;new(ListNode) p.Next&nbsp;=&nbsp;node p&nbsp;=&nbsp;p.Next } } if&nbsp;flag&nbsp;==&nbsp;1&nbsp;{ node&nbsp;:=&nbsp;new(ListNode) node.Val&nbsp;=&nbsp;1 p.Next&nbsp;=&nbsp;node } return&nbsp;head}]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写时复制和引用计数]]></title>
    <url>%2F2017%2F03%2F16%2F%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6%E5%92%8C%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%2F</url>
    <content type="text"><![CDATA[http://www.cnblogs.com/phpcoder/p/4462210.html]]></content>
      <tags>
        <tag>php</tag>
        <tag>写时复制</tag>
        <tag>引用计数</tag>
        <tag>内存</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2017.3]]></title>
    <url>%2F2017%2F03%2F16%2F2017.3%2F</url>
    <content type="text"><![CDATA[git http://www.runoob.com/w3cnote/git-guide.htmljs编辑器 http://www.cnblogs.com/lhb25/p/html5-wysisyg-inline-editor.htmlJavaEE 注解和XMLhttp://blog.csdn.net/qmw19910301/article/details/52712893]]></content>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[php内置数组排序]]></title>
    <url>%2F2017%2F03%2F16%2FPHP%E5%86%85%E7%BD%AE%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"></content>
      <tags>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安装laravel]]></title>
    <url>%2F2017%2F03%2F16%2F%E5%AE%89%E8%A3%85Laravel%2F</url>
    <content type="text"><![CDATA[一、根据官方文档需要安装几个php的扩展 Openssl/PDO/Mbstring/Tokenizer/XML二、Linux下可以使用Composer来安装Laravel&nbsp; 1.全局安装Composer&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;curl -sS https://getcomposer.org/installer | php&nbsp;&nbsp;&nbsp;&nbsp;mv composer.phar /usr/local/bin/composer&nbsp; &nbsp; &nbsp;解决更新慢的问题&nbsp;&nbsp;&nbsp;&nbsp;composer config repo.packagist composer https://packagist.phpcomposer.com&nbsp;&nbsp;&nbsp;&nbsp;composer –version查看是否安装成功&nbsp; 2.利用Composer安装Laravel&nbsp;&nbsp;&nbsp;&nbsp;composer global require &quot;laravel/installer&quot;&nbsp;&nbsp;&nbsp;&nbsp;cd到$Home/.composer/vendor/bin目录下&nbsp;&nbsp;&nbsp;&nbsp;执行 Laravel new Blog&nbsp; 3.最后利用php的内置服务器&nbsp;&nbsp;&nbsp;&nbsp;php artisan serve一些收获&nbsp; &nbsp;1.Linux方面 .tar.gz通过的是源码安装 ./configure –prefix=/usr/local/php 即指定安装路径 卸载的时候只需要删除这个目录下的东西即可 开机自启动 增加环境变量&nbsp; &nbsp;2.php 的两种运行方式的php.ini有可能是不同的,也就是会出现你的web上面的phpinfo()和你直接用CLI执行的php -m发现扩展的开启情况是不相同的，这个时候就需要你运行CLI和web的时候所用的php.ini是同一个文件&nbsp; &nbsp;3.Laravel 从laraval知道了php有一个内置的服务器。]]></content>
      <tags>
        <tag>laravel</tag>
        <tag>php</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[lnmp重启]]></title>
    <url>%2F2017%2F03%2F16%2FNginxPHPMysql%20%E9%87%8D%E5%90%AF%E7%AD%89%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[nginx&nbsp;&nbsp;&nbsp;start：&nbsp;/usr/local/nginx/sbin/nginx&nbsp;&nbsp;stop：&nbsp;/usr/local/nginx/sbin/nginx&nbsp;-s&nbsp;stop&nbsp;&nbsp;reload：&nbsp;/usr/local/nginx/sbin/nginx&nbsp;-s&nbsp;reload&nbsp;&nbsp;#**&nbsp;&nbsp;#php-fpm(fast-cgi)命令&nbsp;&nbsp;&nbsp;start：&nbsp;/usr/local/php/sbin/php-fpm&nbsp;&nbsp;stop：&nbsp;/bin/ps&nbsp;-ef&nbsp;|&nbsp;grep&nbsp;&#39;php-fpm&#39;&nbsp;|&nbsp;grep&nbsp;-v&nbsp;grep&nbsp;|&nbsp;cut&nbsp;-c&nbsp;9-15&nbsp;|&nbsp;xargs&nbsp;kill&nbsp;-9&nbsp;&nbsp;&nbsp;Linux：PHP&nbsp;5.3.3&nbsp;以上版本的php-fpm的重启&nbsp;INT,&nbsp;TERM：立刻终止QUIT：平滑终止USR1：重新打开日志文件USR2：平滑重载所有worker进程并重新载入配置和二进制模块&nbsp;示例：1）php-fpm&nbsp;关闭：kill&nbsp;-INT&nbsp;cat&amp;nbsp;/usr/local/php/var/run/php-fpm.pid&nbsp;2）php-fpm&nbsp;重启：kill&nbsp;-USR2&nbsp;cat&amp;nbsp;/usr/local/php/var/run/php-fpm.pid&nbsp;查看php-fpm进程数：ps&nbsp;aux&nbsp;|&nbsp;grep&nbsp;-c&nbsp;php-fpm&nbsp;#**&nbsp;&nbsp;#mysql命令&nbsp;&nbsp;start：&nbsp;/etc/init.d/mysqld&nbsp;start&nbsp;&nbsp;stop：&nbsp;/etc/init.d/mysqld&nbsp;stop&nbsp;&nbsp;restart：&nbsp;/etc/init.d/mysqld&nbsp;restart&nbsp;&nbsp;#**&nbsp;]]></content>
      <tags>
        <tag>lnmp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则]]></title>
    <url>%2F2017%2F03%2F16%2F%E6%AD%A3%E5%88%99%E3%80%81mb_substr%2F</url>
    <content type="text"><![CDATA[0x1 爬虫过程遇到需要截取到&lt;span id=&quot;xhxm&quot;&gt;张三同学&lt;/span&gt;里面同学的名称&nbsp; 1.正则解决&nbsp; 2.通过字符串解决0x2 通过正则解决&nbsp; 1.简单解决&nbsp; &lt;span id=&quot;xhxm&quot;&gt;(.)\u540c\u5b66&lt;/span&gt;&nbsp;&nbsp; 2.零宽断言解决&nbsp; &nbsp;&gt;(.)(?=\u540c\u5b66)&nbsp;&nbsp;&nbsp; 这里使用零宽度正预测先行断言(?=exp)&nbsp; 就是找到匹配之前的内容&nbsp;&nbsp; (?&lt;=exp)用来找到匹配之后的东西，称为零宽度正回顾后发断言0x3 通过mb_substr解决 先匹配张三同学,然后截取字符串&nbsp; 因为这里的header是gb2312，所以指定mb_substr的编码为gb2312&nbsp; substr直接处理汉字会造成乱码的问题，可以使用mb_substr指定汉字编码方式gb2312&nbsp;&nbsp; 这样就可以截取到到张三0x4 这不算完&nbsp;]]></content>
      <tags>
        <tag>正则</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最长不重复子串]]></title>
    <url>%2F2017%2F03%2F16%2F%E8%AE%A1%E7%AE%97%E4%B8%80%E4%B8%AA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E6%9C%80%E5%A4%A7%E4%B8%8D%E9%87%8D%E5%A4%8D%E5%AD%90%E4%B8%B2%E9%95%BF%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[123456789101112131415161718192021222324252627282930package mainimport ( "fmt ")func maxLen(str string) int &#123; start := 0 maxlen := 0 lastO := make(map[rune]int) for i, v := range []rune(str) &#123; if lastI, ok := lastO[v]; ok &#123; start = lastI + 1 &#125; if (i-start+1 &amp;gt; maxlen) &#123; maxlen = i - start + 1 &#125; lastO[v] = i &#125; return maxlen&#125;func main() &#123; //求字符串最大不重复子串长度 //s:= "Yes哈哈哈! " fmt.Println(maxLen( "abcbcdef ")) fmt.Println(maxLen( "abcdef ")) fmt.Println(maxLen( "aaaaaaa ")) fmt.Println(maxLen( "你说什么 "))&#125;]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基本排序算法]]></title>
    <url>%2F2017%2F03%2F16%2F%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[使用四种基本的排序方法对生成的1000个随机数进行排序，比较执行时间一、冒泡排序123456789101112131415161718192021222324$s=microtime();//记录开始时间for($i=0;$i=1000;$i++)&#123; $a[$i] = mt_rand(0,1000);&#125;//冒泡排序for($j=0;$j&lt;999;$j++)&#123; for($k=0;$k&lt;999-$j;$k++)&#123; if($a[$k]&gt;$a[$k+1])&#123; $temp = $a[$k]; $a[$k] = $a[$k+1]; $a[$k+1] = $temp; &#125; &#125;&#125;for($i=0;$i&lt;1000;$i++)&#123; echo $a[$i].&apos;&apos;;&#125;$e = microtime();//记录结束时间echo &apos;&lt;br/&gt;&apos;;echo $e-$s; 二、简单选择排序123456789for($i=0;$i&lt;999;$i++)&#123; for($j=$i+1;$j&lt;1000;$j++)&#123; if($a[$j]&lt;$a[$i])&#123; $temp = $a[$j]; $a[$j] = $a[$i]; $a[$i] = $temp; &#125; &#125;&#125; 三、直接插入排序12345678910for($i=1;$i&lt;1000;$i++)&#123; if($a[$i]&lt;$a[$i-1])&#123; $j = $i-1; $temp = $a[$i]; for($j;$j&gt;=0&amp;amp;&amp;amp;$a[$j]&gt;$temp;$j--)&#123; $a[$j+1] = $a[$j]; &#125; $a[$j+1] = $temp; &#125;&#125; 四、快速排序123456789101112131415161718192021222324252627function qsort($left,$right)&#123; if($left&gt;$right)&#123; return; &#125; global $a; $i=$left; $j=$right; $key = $i; while($i&lt;$j)&#123; //从右往左找到第一个小于标记的值，交换 while($a[$j]&gt;=$a[$key]&amp;amp;&amp;amp;$j&gt;$i)$j--; $temp = $a[$i]; $a[$i] = $a[$j]; $a[$j] = $temp; $key = $j; //从左往右找到第一个大于标记的值，交换 while($a[$i]&lt;=$a[$key]&amp;amp;&amp;amp;$i&lt;$j)$i++; $temp = $a[$i]; $a[$i] = $a[$j]; $a[$j] = $temp; $key = $i;&#125;//递归调用qsort($left,$i-1);qsort($i+1,$right);qsort(0,999); 多次测试结果冒泡排序0.05~0.07 简单选择0.03~0.06 直接插入0.02~0.04 快速排序0.002~0.007]]></content>
      <tags>
        <tag>排序</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[apache]]></title>
    <url>%2F2017%2F03%2F16%2F%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85apache%20%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%2F</url>
    <content type="text"><![CDATA[1.下载httpd apr apr-util pcre配置安装apr .configure –with-prefix=/…./apa/apr&nbsp;make &amp;&amp; make install配置安装apr-util .configure –with-prefix=/…./apa/apr-util&nbsp;make &amp;&amp; make install配置安装pcre .configure –with-prefix=/…./local/pcre&nbsp;make &amp;&amp; make install配置安装apache httpd&nbsp;./configure –prefix=/usr/local/apache2 –with-mpm=worker –enable-cache –enable-disk-cache –enable-mem-cache –enable-file-cache –enable-nonportable-atomics –enable-mods-shared=most –enable-so –enable-rewrite –enable-ssl –with-apr=/../apr安装目录 –with-apr-util=/…/apr-util安装目录 –with-pcre=pcre安装目录make &amp;&amp; make install&nbsp;php configure 参数 http://www.mamicode.com/info-detail-32029.html]]></content>
      <tags>
        <tag>apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试算法题]]></title>
    <url>%2F2017%2F03%2F16%2F%E9%9D%A2%E8%AF%95%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[package&nbsp;main import&nbsp;(&nbsp;&nbsp;&nbsp;&quot;fmt&quot;&nbsp;&nbsp;&nbsp;&quot;strconv&quot;&nbsp;&nbsp;&nbsp;&quot;sort&quot;) func&nbsp;filter(str&nbsp;string)&nbsp;string{&nbsp;&nbsp;&nbsp;//过滤aabbbbbccc&nbsp;为abc&nbsp;&nbsp;&nbsp;var&nbsp;newArr&nbsp;=&nbsp;make(map[rune]int)&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;&quot;&quot; &nbsp;&nbsp;&nbsp;for&nbsp;_,v&nbsp;:=&nbsp;range&nbsp;[]rune(str){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;newArr[v]&nbsp;==&nbsp;0{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr[v]&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;+=&nbsp;string(v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;return&nbsp;s} func&nbsp;filter2(str&nbsp;string)&nbsp;string{&nbsp;&nbsp;&nbsp;//过滤aaabbbcssss为3a3bc4s&nbsp;&nbsp;&nbsp;var&nbsp;newArr&nbsp;=&nbsp;make(map[rune]int)&nbsp;&nbsp;&nbsp;var&nbsp;sortArr&nbsp;[]string&nbsp;&nbsp;&nbsp;s&nbsp;:=&nbsp;&quot;&quot; &nbsp;&nbsp;&nbsp;for&nbsp;_,v&nbsp;:=&nbsp;range&nbsp;[]rune(str){&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sortArr&nbsp;=&nbsp;append(sortArr,&nbsp;string(v))&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;newArr[v]&nbsp;==&nbsp;0{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr[v]&nbsp;=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;newArr[v]&nbsp;+=&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;} &nbsp;&nbsp;&nbsp;sort.Strings(sortArr) &nbsp;&nbsp;&nbsp;for&nbsp;i,v&nbsp;:=&nbsp;range&nbsp;newArr{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if&nbsp;v&nbsp;==&nbsp;1&nbsp;{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;+=&nbsp;string(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else{&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;+=&nbsp;strconv.Itoa(v)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;s&nbsp;+=&nbsp;string(i)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;}&nbsp;&nbsp;&nbsp;return&nbsp;s} func&nbsp;main()&nbsp;{&nbsp;&nbsp;&nbsp;fmt.Println(filter2(&quot;aabccddee&quot;))}go语言的map用for range遍历是随机的key所以如果需要顺序遍历则需要先将key排序]]></content>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git]]></title>
    <url>%2F2017%2F03%2F16%2FGithub%2F</url>
    <content type="text"><![CDATA[首先有两种使用方式 1.先在git官网上建立一个git仓库，然后git clone到本地&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2.直接在本地cd进一个文件夹 git init配置用户名和email&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;git config –global user.name &#39;&#39;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;git config –global user.email xxx@xxx.com简单使用命令 &nbsp;git add .&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git status&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; git commit -m &quot;The First Upload&quot;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;git push -u origin master&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;]]></content>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode-1]]></title>
    <url>%2F2017%2F03%2F16%2Fleetcode_day1%2F</url>
    <content type="text"><![CDATA[1.&nbsp;Two SumGiven an array of integers, return&nbsp;indices&nbsp;of the two numbers such that they add up to a specific target.You may assume that each input would have&nbsp;exactly&nbsp;one solution, and you may not use the&nbsp;same&nbsp;element twice.Example:Given&nbsp;nums&nbsp;=&nbsp;[2,&nbsp;7,&nbsp;11,&nbsp;15],&nbsp;target&nbsp;=&nbsp;9,Because&nbsp;nums[0]&nbsp;+&nbsp;nums[1]&nbsp;=&nbsp;2&nbsp;+&nbsp;7&nbsp;=&nbsp;9,return&nbsp;[0,&nbsp;1].func&nbsp;twoSum(nums&nbsp;[]int,&nbsp;target&nbsp;int)&nbsp;[]int&nbsp;{ var&nbsp;arr&nbsp;[]intEXIT: for&nbsp;i,&nbsp;&nbsp;:=&nbsp;range&nbsp;nums&nbsp;{ for&nbsp;j,&nbsp;&nbsp;:=&nbsp;range&nbsp;nums&nbsp;{ if&nbsp;(nums[i]+nums[j])&nbsp;==&nbsp;target&nbsp;&amp;&amp;&nbsp;i&nbsp;!=&nbsp;j&nbsp;{ arr&nbsp;=&nbsp;append(arr,&nbsp;i) arr&nbsp;=&nbsp;append(arr,&nbsp;j) break&nbsp;EXIT } } } return&nbsp;arr}]]></content>
      <tags>
        <tag>leetcode</tag>
      </tags>
  </entry>
</search>
